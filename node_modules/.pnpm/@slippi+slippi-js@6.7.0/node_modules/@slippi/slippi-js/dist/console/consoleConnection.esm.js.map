{"version":3,"file":"consoleConnection.esm.js","sources":["../../src/console/consoleConnection.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\nimport net from \"net\";\nimport inject from \"reconnect-core\";\n\nimport type { CommunicationMessage } from \"./communication\";\nimport { CommunicationType, ConsoleCommunication } from \"./communication\";\nimport type { Connection, ConnectionDetails, ConnectionSettings } from \"./types\";\nimport { ConnectionEvent, ConnectionStatus, Ports } from \"./types\";\n\nexport const NETWORK_MESSAGE = \"HELO\\0\";\n\nconst DEFAULT_CONNECTION_TIMEOUT_MS = 20000;\n\nenum CommunicationState {\n  INITIAL = \"initial\",\n  LEGACY = \"legacy\",\n  NORMAL = \"normal\",\n}\n\nconst defaultConnectionDetails: ConnectionDetails = {\n  consoleNick: \"unknown\",\n  gameDataCursor: Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0]),\n  version: \"\",\n  clientToken: 0,\n};\n\nconst consoleConnectionOptions = {\n  autoReconnect: true,\n};\n\nexport type ConsoleConnectionOptions = typeof consoleConnectionOptions;\n\n/**\n * Responsible for maintaining connection to a Slippi relay connection or Wii connection.\n * Events are emitted whenever data is received.\n *\n * Basic usage example:\n *\n * ```javascript\n * const { ConsoleConnection } = require(\"@slippi/slippi-js\");\n *\n * const connection = new ConsoleConnection();\n * connection.connect(\"localhost\", 667); // You should set these values appropriately\n *\n * connection.on(\"data\", (data) => {\n *   // Received data from console\n *   console.log(data);\n * });\n *\n * connection.on(\"statusChange\", (status) => {\n *   console.log(`status changed: ${status}`);\n * });\n * ```\n */\nexport class ConsoleConnection extends EventEmitter implements Connection {\n  private ipAddress: string;\n  private port: number;\n  private isRealtime: boolean;\n  private connectionStatus = ConnectionStatus.DISCONNECTED;\n  private connDetails: ConnectionDetails = { ...defaultConnectionDetails };\n  private client: net.Socket | null = null;\n  private connection: inject.Instance<unknown, net.Socket> | null = null;\n  private options: ConsoleConnectionOptions;\n  private shouldReconnect = false;\n\n  public constructor(options?: Partial<ConsoleConnectionOptions>) {\n    super();\n    this.ipAddress = \"0.0.0.0\";\n    this.port = Ports.DEFAULT;\n    this.isRealtime = false;\n    this.options = Object.assign({}, consoleConnectionOptions, options);\n  }\n\n  /**\n   * @returns The current connection status.\n   */\n  public getStatus(): ConnectionStatus {\n    return this.connectionStatus;\n  }\n\n  /**\n   * @returns The IP address and port of the current connection.\n   */\n  public getSettings(): ConnectionSettings {\n    return {\n      ipAddress: this.ipAddress,\n      port: this.port,\n    };\n  }\n\n  /**\n   * @returns The specific details about the connected console.\n   */\n  public getDetails(): ConnectionDetails {\n    return { ...this.connDetails };\n  }\n\n  /**\n   * Initiate a connection to the Wii or Slippi relay.\n   * @param ip   The IP address of the Wii or Slippi relay.\n   * @param port The port to connect to.\n   * @param isRealtime Optional. A flag to tell the Wii to send data as quickly as possible\n   * @param timeout Optional. The timeout in milliseconds when attempting to connect\n   *                to the Wii or relay.\n   */\n  public connect(ip: string, port: number, isRealtime = false, timeout = DEFAULT_CONNECTION_TIMEOUT_MS): void {\n    this.ipAddress = ip;\n    this.port = port;\n    this.isRealtime = isRealtime;\n    this._connectOnPort(ip, port, timeout);\n  }\n\n  private _connectOnPort(ip: string, port: number, timeout: number): void {\n    // set up reconnect\n    const reconnect = inject(() =>\n      net.connect({\n        host: ip,\n        port: port,\n        timeout: timeout,\n      }),\n    );\n\n    // Indicate we are connecting\n    this._setStatus(ConnectionStatus.CONNECTING);\n\n    // Prepare console communication obj for talking UBJSON\n    const consoleComms = new ConsoleCommunication();\n\n    // TODO: reconnect on failed reconnect, not sure how\n    // TODO: to do this\n    const connection = reconnect(\n      {\n        initialDelay: 2000,\n        maxDelay: 10000,\n        strategy: \"fibonacci\",\n        failAfter: Infinity,\n      },\n      (client) => {\n        this.emit(ConnectionEvent.CONNECT);\n        // We successfully connected so turn on auto-reconnect\n        this.shouldReconnect = this.options.autoReconnect;\n        this.client = client;\n\n        let commState: CommunicationState = CommunicationState.INITIAL;\n        client.on(\"data\", (data) => {\n          if (commState === CommunicationState.INITIAL) {\n            commState = this._getInitialCommState(data);\n            console.log(`Connected to ${ip}:${port} with type: ${commState}`);\n            this._setStatus(ConnectionStatus.CONNECTED);\n            console.log(data.toString(\"hex\"));\n          }\n\n          if (commState === CommunicationState.LEGACY) {\n            // If the first message received was not a handshake message, either we\n            // connected to an old Nintendont version or a relay instance\n            this._handleReplayData(data);\n            return;\n          }\n\n          try {\n            consoleComms.receive(data);\n          } catch (err) {\n            console.error(\"Failed to process new data from server...\", {\n              error: err,\n              prevDataBuf: consoleComms.getReceiveBuffer(),\n              rcvData: data,\n            });\n            client.destroy();\n            this.emit(ConnectionEvent.ERROR, err);\n            return;\n          }\n          const messages = consoleComms.getMessages();\n\n          // Process all of the received messages\n          try {\n            messages.forEach((message) => this._processMessage(message));\n          } catch (err) {\n            // Disconnect client to send another handshake message\n            console.error(err);\n            client.destroy();\n            this.emit(ConnectionEvent.ERROR, err);\n          }\n        });\n\n        client.on(\"timeout\", () => {\n          // const previouslyConnected = this.connectionStatus === ConnectionStatus.CONNECTED;\n          console.warn(`Attempted connection to ${ip}:${port} timed out after ${timeout}ms`);\n          client.destroy();\n        });\n\n        client.on(\"end\", () => {\n          console.log(\"disconnect\");\n          if (!this.shouldReconnect) {\n            client.destroy();\n          }\n        });\n\n        client.on(\"close\", () => {\n          console.log(\"connection was closed\");\n        });\n\n        const handshakeMsgOut = consoleComms.genHandshakeOut(\n          this.connDetails.gameDataCursor as Uint8Array,\n          this.connDetails.clientToken ?? 0,\n          this.isRealtime,\n        );\n\n        client.write(handshakeMsgOut);\n      },\n    );\n\n    const setConnectingStatus = (): void => {\n      // Indicate we are connecting\n      this._setStatus(this.shouldReconnect ? ConnectionStatus.RECONNECT_WAIT : ConnectionStatus.CONNECTING);\n    };\n\n    connection.on(\"connect\", setConnectingStatus);\n    connection.on(\"reconnect\", setConnectingStatus);\n\n    connection.on(\"disconnect\", () => {\n      if (!this.shouldReconnect) {\n        connection.reconnect = false;\n        connection.disconnect();\n        this._setStatus(ConnectionStatus.DISCONNECTED);\n      }\n      // TODO: Figure out how to set RECONNECT_WAIT state here. Currently it will stay on\n      // TODO: Connecting... forever\n    });\n\n    connection.on(\"error\", (err) => {\n      console.warn(`Connection on port ${port} encountered an error.`, err);\n\n      this._setStatus(ConnectionStatus.DISCONNECTED);\n      this.emit(ConnectionEvent.ERROR, `Connection on port ${port} encountered an error.\\n${err}`);\n    });\n\n    this.connection = connection;\n    connection.connect(port);\n  }\n\n  /**\n   * Terminate the current connection.\n   */\n  public disconnect(): void {\n    // Prevent reconnections and disconnect\n    if (this.connection) {\n      this.connection.reconnect = false;\n      this.connection.disconnect();\n      this.connection = null;\n    }\n\n    if (this.client) {\n      this.client.destroy();\n    }\n  }\n\n  private _getInitialCommState(data: Buffer): CommunicationState {\n    if (data.length < 13) {\n      return CommunicationState.LEGACY;\n    }\n\n    const openingBytes = Buffer.from([0x7b, 0x69, 0x04, 0x74, 0x79, 0x70, 0x65, 0x55, 0x01]);\n\n    const dataStart = data.slice(4, 13);\n\n    return dataStart.equals(openingBytes) ? CommunicationState.NORMAL : CommunicationState.LEGACY;\n  }\n\n  private _processMessage(message: CommunicationMessage): void {\n    this.emit(ConnectionEvent.MESSAGE, message);\n    switch (message.type) {\n      case CommunicationType.KEEP_ALIVE:\n        // console.log(\"Keep alive message received\");\n\n        // TODO: This is the jankiest shit ever but it will allow for relay connections not\n        // TODO: to time out as long as the main connection is still receving keep alive messages\n        // TODO: Need to figure out a better solution for this. There should be no need to have an\n        // TODO: active Wii connection for the relay connection to keep itself alive\n        const fakeKeepAlive = Buffer.from(NETWORK_MESSAGE);\n        this._handleReplayData(fakeKeepAlive);\n\n        break;\n      case CommunicationType.REPLAY:\n        const readPos = Uint8Array.from(message.payload.pos);\n        const cmp = Buffer.compare(this.connDetails.gameDataCursor as Uint8Array, readPos);\n        if (!message.payload.forcePos && cmp !== 0) {\n          // The readPos is not the one we are waiting on, throw error\n          throw new Error(\n            `Position of received data is incorrect. Expected: ${this.connDetails.gameDataCursor.toString()}, Received: ${readPos.toString()}`,\n          );\n        }\n\n        if (message.payload.forcePos) {\n          console.warn(\n            \"Overflow occured in Nintendont, data has likely been skipped and replay corrupted. \" +\n              \"Expected, Received:\",\n            this.connDetails.gameDataCursor,\n            readPos,\n          );\n        }\n\n        this.connDetails.gameDataCursor = Uint8Array.from(message.payload.nextPos);\n\n        const data = Uint8Array.from(message.payload.data);\n        this._handleReplayData(data);\n        break;\n      case CommunicationType.HANDSHAKE:\n        const { nick, nintendontVersion } = message.payload;\n        if (nick) {\n          this.connDetails.consoleNick = nick;\n        }\n        const tokenBuf = Buffer.from(message.payload.clientToken);\n        this.connDetails.clientToken = tokenBuf.readUInt32BE(0);\n        if (nintendontVersion) {\n          this.connDetails.version = nintendontVersion;\n        }\n        this.connDetails.gameDataCursor = Uint8Array.from(message.payload.pos);\n        this.emit(ConnectionEvent.HANDSHAKE, this.connDetails);\n        break;\n      default:\n        // Should this be an error?\n        break;\n    }\n  }\n\n  private _handleReplayData(data: Uint8Array): void {\n    this.emit(ConnectionEvent.DATA, data);\n  }\n\n  private _setStatus(status: ConnectionStatus): void {\n    // Don't fire the event if the status hasn't actually changed\n    if (this.connectionStatus !== status) {\n      this.connectionStatus = status;\n      this.emit(ConnectionEvent.STATUS_CHANGE, this.connectionStatus);\n    }\n  }\n}\n"],"names":["NETWORK_MESSAGE","DEFAULT_CONNECTION_TIMEOUT_MS","CommunicationState","defaultConnectionDetails","consoleNick","gameDataCursor","Uint8Array","from","version","clientToken","consoleConnectionOptions","autoReconnect","ConsoleConnection","EventEmitter","constructor","options","ipAddress","port","isRealtime","connectionStatus","ConnectionStatus","DISCONNECTED","connDetails","client","connection","shouldReconnect","Ports","DEFAULT","Object","assign","getStatus","getSettings","getDetails","connect","ip","timeout","_connectOnPort","reconnect","inject","net","host","_setStatus","CONNECTING","consoleComms","ConsoleCommunication","initialDelay","maxDelay","strategy","failAfter","Infinity","emit","ConnectionEvent","CONNECT","commState","INITIAL","on","data","_getInitialCommState","console","log","CONNECTED","toString","LEGACY","_handleReplayData","receive","err","error","prevDataBuf","getReceiveBuffer","rcvData","destroy","ERROR","messages","getMessages","forEach","message","_processMessage","warn","handshakeMsgOut","genHandshakeOut","write","setConnectingStatus","RECONNECT_WAIT","disconnect","length","openingBytes","Buffer","dataStart","slice","equals","NORMAL","MESSAGE","type","CommunicationType","KEEP_ALIVE","fakeKeepAlive","REPLAY","readPos","payload","pos","cmp","compare","forcePos","Error","nextPos","HANDSHAKE","nick","nintendontVersion","tokenBuf","readUInt32BE","DATA","status","STATUS_CHANGE"],"mappings":"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"}