/**
 * Copyright IBM Corp. 2016, 2023
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

import { defineProperty as _defineProperty, extends as _extends } from '../../_virtual/_rollupPluginBabelHelpers.js';
import invariant from 'invariant';
import PropTypes from 'prop-types';
import React__default, { Component } from 'react';
import cx from 'classnames';
import ClickListener from '../../internal/ClickListener.js';
import FloatingMenu, { DIRECTION_TOP, DIRECTION_BOTTOM } from '../../internal/FloatingMenu.js';
import { OverflowMenuVertical } from '@carbon/icons-react';
import mergeRefs from '../../tools/mergeRefs.js';
import { PrefixContext } from '../../internal/usePrefix.js';
import deprecate from '../../prop-types/deprecate.js';
import { IconButton } from '../IconButton/index.js';
import setupGetInstanceId from '../../tools/setupGetInstanceId.js';
import { noopFn } from '../../internal/noopFn.js';
import { matches } from '../../internal/keyboard/match.js';
import { ArrowUp, ArrowRight, ArrowDown, ArrowLeft, Escape } from '../../internal/keyboard/keys.js';

const getInstanceId = setupGetInstanceId();
const on = function (element) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  element.addEventListener(...args);
  return {
    release() {
      element.removeEventListener(...args);
      return null;
    }
  };
};

/**
 * The CSS property names of the arrow keyed by the floating menu direction.
 * @type {[key: string]: string}
 */
const triggerButtonPositionProps = {
  [DIRECTION_TOP]: 'bottom',
  [DIRECTION_BOTTOM]: 'top'
};

/**
 * Determines how the position of arrow should affect the floating menu position.
 * @type {[key: string]: number}
 */
const triggerButtonPositionFactors = {
  [DIRECTION_TOP]: -2,
  [DIRECTION_BOTTOM]: -1
};

/**
 * @param {Element} menuBody The menu body with the menu arrow.
 * @param {string} direction The floating menu direction.
 * @returns {FloatingMenu~offset} The adjustment of the floating menu position, upon the position of the menu arrow.
 * @private
 */
const getMenuOffset = (menuBody, direction, trigger, flip) => {
  const triggerButtonPositionProp = triggerButtonPositionProps[direction];
  const triggerButtonPositionFactor = triggerButtonPositionFactors[direction];
  if (process.env.NODE_ENV !== "production") {
    !(triggerButtonPositionProp && triggerButtonPositionFactor) ? process.env.NODE_ENV !== "production" ? invariant(false, '[OverflowMenu] wrong floating menu direction: `%s`', direction) : invariant(false) : void 0;
  }
  const {
    offsetWidth: menuWidth,
    offsetHeight: menuHeight
  } = menuBody;
  switch (triggerButtonPositionProp) {
    case 'top':
    case 'bottom':
      {
        // TODO: Ensure `trigger` is there for `<OverflowMenu open>`
        const triggerWidth = !trigger ? 0 : trigger.offsetWidth;
        return {
          left: (!flip ? 1 : -1) * (menuWidth / 2 - triggerWidth / 2),
          top: 0
        };
      }
    case 'left':
    case 'right':
      {
        // TODO: Ensure `trigger` is there for `<OverflowMenu open>`
        const triggerHeight = !trigger ? 0 : trigger.offsetHeight;
        return {
          left: 0,
          top: (!flip ? 1 : -1) * (menuHeight / 2 - triggerHeight / 2)
        };
      }
  }
};
class OverflowMenu extends Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "state", {});
    _defineProperty(this, "instanceId", getInstanceId());
    /**
     * The handle of `onfocusin` or `focus` event handler.
     * @private
     */
    _defineProperty(this, "_hFocusIn", null);
    /**
     * The timeout handle for handling `blur` event.
     * @private
     */
    _defineProperty(this, "_hBlurTimeout", void 0);
    /**
     * The element ref of the tooltip's trigger button.
     * @type {React.RefObject<Element>}
     * @private
     */
    _defineProperty(this, "_triggerRef", /*#__PURE__*/React__default.createRef());
    _defineProperty(this, "handleClick", evt => {
      const {
        onClick = noopFn
      } = this.props;
      evt.stopPropagation();
      if (!this._menuBody || !this._menuBody.contains(evt.target)) {
        this.setState({
          open: !this.state.open
        });
        onClick(evt);
      }
    });
    _defineProperty(this, "closeMenuAndFocus", () => {
      let wasOpen = this.state.open;
      this.closeMenu(() => {
        if (wasOpen) {
          this.focusMenuEl();
        }
      });
    });
    _defineProperty(this, "handleKeyPress", evt => {
      if (this.state.open && matches(evt, [ArrowUp, ArrowRight, ArrowDown, ArrowLeft])) {
        evt.preventDefault();
      }

      // Close the overflow menu on escape
      if (matches(evt, [Escape])) {
        this.closeMenuAndFocus();

        // Stop the esc keypress from bubbling out and closing something it shouldn't
        evt.stopPropagation();
      }
    });
    _defineProperty(this, "handleClickOutside", evt => {
      if (this.state.open && (!this._menuBody || !this._menuBody.contains(evt.target))) {
        this.closeMenu();
      }
    });
    _defineProperty(this, "closeMenu", onCloseMenu => {
      const {
        onClose = noopFn
      } = this.props;
      this.setState({
        open: false
      }, () => {
        // Optional callback to be executed after the state as been set to close
        if (onCloseMenu) {
          onCloseMenu();
        }
        onClose();
      });
    });
    _defineProperty(this, "focusMenuEl", () => {
      const {
        current: triggerEl
      } = this._triggerRef;
      if (triggerEl) {
        triggerEl.focus();
      }
    });
    /**
     * Focuses the next enabled overflow menu item given the currently focused
     * item index and direction to move
     * @param {object} params
     * @param {number} params.currentIndex - the index of the currently focused
     * overflow menu item in the list of overflow menu items
     * @param {number} params.direction - number denoting the direction to move
     * focus (1 for forwards, -1 for backwards)
     */
    _defineProperty(this, "handleOverflowMenuItemFocus", _ref => {
      let {
        currentIndex,
        direction
      } = _ref;
      const enabledIndices = React__default.Children.toArray(this.props.children).reduce((acc, curr, i) => {
        if (!curr.props.disabled) {
          acc.push(i);
        }
        return acc;
      }, []);
      const nextValidIndex = (() => {
        const nextIndex = enabledIndices.indexOf(currentIndex) + direction;
        switch (nextIndex) {
          case -1:
            return enabledIndices.length - 1;
          case enabledIndices.length:
            return 0;
          default:
            return nextIndex;
        }
      })();
      const overflowMenuItem = this[`overflowMenuItem${enabledIndices[nextValidIndex]}`];
      overflowMenuItem?.focus();
    });
    /**
     * Handles the floating menu being unmounted or non-floating menu being
     * mounted or unmounted.
     * @param {Element} menuBody The DOM element of the menu body.
     * @private
     */
    _defineProperty(this, "_bindMenuBody", menuBody => {
      if (!menuBody) {
        this._menuBody = menuBody;
      }
      if (!menuBody && this._hFocusIn) {
        this._hFocusIn = this._hFocusIn.release();
      }
    });
    /**
     * Handles the floating menu being placed.
     * @param {Element} menuBody The DOM element of the menu body.
     * @private
     */
    _defineProperty(this, "_handlePlace", menuBody => {
      const {
        onOpen = noopFn
      } = this.props;
      if (menuBody) {
        this._menuBody = menuBody;
        const hasFocusin = ('onfocusin' in window);
        const focusinEventName = hasFocusin ? 'focusin' : 'focus';
        this._hFocusIn = on(menuBody.ownerDocument, focusinEventName, event => {
          const target = ClickListener.getEventTarget(event);
          const {
            current: triggerEl
          } = this._triggerRef;
          if (typeof target.matches === 'function') {
            if (!menuBody.contains(target) && triggerEl && !target.matches(`.${this.context}--overflow-menu,.${this.context}--overflow-menu-options`)) {
              this.closeMenuAndFocus();
            }
          }
        }, !hasFocusin);
        onOpen();
      }
    });
    /**
     * @returns {Element} The DOM element where the floating menu is placed in.
     */
    _defineProperty(this, "_getTarget", () => {
      const {
        current: triggerEl
      } = this._triggerRef;
      return triggerEl && triggerEl.closest('[data-floating-menu-container]') || document.body;
    });
  }
  componentDidUpdate(_, prevState) {
    const {
      onClose = noopFn
    } = this.props;
    if (!this.state.open && prevState.open) {
      onClose();
    }
  }
  componentDidMount() {
    // ensure that if open=true on first render, we wait
    // to render the floating menu until the trigger ref is not null
    if (this._triggerRef.current) {
      this.setState({
        hasMountedTrigger: true
      });
    }
  }
  static getDerivedStateFromProps(_ref2, state) {
    let {
      open
    } = _ref2;
    const {
      prevOpen
    } = state;
    return prevOpen === open ? null : {
      open,
      prevOpen: open
    };
  }
  componentWillUnmount() {
    if (typeof this._hBlurTimeout === 'number') {
      clearTimeout(this._hBlurTimeout);
      this._hBlurTimeout = undefined;
    }
  }
  render() {
    const prefix = this.context;
    const {
      id,
      ['aria-label']: ariaLabel = null,
      ariaLabel: deprecatedAriaLabel,
      children,
      iconDescription = 'Options',
      direction = DIRECTION_BOTTOM,
      flipped = false,
      focusTrap = true,
      menuOffset = getMenuOffset,
      menuOffsetFlip = getMenuOffset,
      iconClass,
      onClick = noopFn,
      // eslint-disable-line
      onOpen = noopFn,
      // eslint-disable-line
      selectorPrimaryFocus = '[data-floating-menu-primary-focus]',
      // eslint-disable-line
      renderIcon: IconElement = OverflowMenuVertical,
      // eslint-disable-next-line react/prop-types
      innerRef: ref,
      menuOptionsClass,
      light,
      size = 'md',
      ...other
    } = this.props;
    const {
      open = false
    } = this.state;
    const overflowMenuClasses = cx(this.props.className, `${prefix}--overflow-menu`, {
      [`${prefix}--overflow-menu--open`]: open,
      [`${prefix}--overflow-menu--light`]: light,
      [`${prefix}--overflow-menu--${size}`]: size
    });
    const overflowMenuOptionsClasses = cx(menuOptionsClass, `${prefix}--overflow-menu-options`, {
      [`${prefix}--overflow-menu--flip`]: this.props.flipped,
      [`${prefix}--overflow-menu-options--open`]: open,
      [`${prefix}--overflow-menu-options--light`]: light,
      [`${prefix}--overflow-menu-options--${size}`]: size
    });
    const overflowMenuIconClasses = cx(`${prefix}--overflow-menu__icon`, iconClass);
    const childrenWithProps = React__default.Children.toArray(children).map((child, index) => /*#__PURE__*/React__default.cloneElement(child, {
      closeMenu: child?.props?.closeMenu || this.closeMenuAndFocus,
      handleOverflowMenuItemFocus: this.handleOverflowMenuItemFocus,
      ref: e => {
        this[`overflowMenuItem${index}`] = e;
      },
      index
    }));
    const menuBodyId = `overflow-menu-${this.instanceId}__menu-body`;
    const menuBody = /*#__PURE__*/React__default.createElement("ul", {
      className: overflowMenuOptionsClasses,
      tabIndex: "-1",
      role: "menu",
      "aria-label": ariaLabel || deprecatedAriaLabel,
      onKeyDown: this.handleKeyPress,
      id: menuBodyId
    }, childrenWithProps);
    const wrappedMenuBody = /*#__PURE__*/React__default.createElement(FloatingMenu, {
      focusTrap: focusTrap,
      triggerRef: this._triggerRef,
      menuDirection: direction,
      menuOffset: flipped ? menuOffsetFlip : menuOffset,
      menuRef: this._bindMenuBody,
      flipped: this.props.flipped,
      target: this._getTarget,
      onPlace: this._handlePlace,
      selectorPrimaryFocus: this.props.selectorPrimaryFocus
    }, /*#__PURE__*/React__default.cloneElement(menuBody, {
      'data-floating-menu-direction': direction
    }));
    const iconProps = {
      className: overflowMenuIconClasses,
      'aria-label': iconDescription
    };
    return /*#__PURE__*/React__default.createElement(ClickListener, {
      onClickOutside: this.handleClickOutside
    }, /*#__PURE__*/React__default.createElement("span", {
      className: `${prefix}--overflow-menu__wrapper`,
      "aria-owns": open ? menuBodyId : null
    }, /*#__PURE__*/React__default.createElement(IconButton, _extends({}, other, {
      type: "button",
      "aria-haspopup": true,
      "aria-expanded": open,
      "aria-controls": open ? menuBodyId : null,
      className: overflowMenuClasses,
      onClick: this.handleClick,
      id: id,
      ref: mergeRefs(this._triggerRef, ref),
      size: size,
      label: iconDescription
    }), /*#__PURE__*/React__default.createElement(IconElement, iconProps)), open && this.state.hasMountedTrigger && wrappedMenuBody));
  }
}
_defineProperty(OverflowMenu, "propTypes", {
  /**
   * Specify a label to be read by screen readers on the container node
   */
  ['aria-label']: PropTypes.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify a label to be read by screen readers on the container note.
   */
  ariaLabel: deprecate(PropTypes.string, 'This prop syntax has been deprecated. Please use the new `aria-label`.'),
  /**
   * The child nodes.
   */
  children: PropTypes.node,
  /**
   * The CSS class names.
   */
  className: PropTypes.string,
  /**
   * The menu direction.
   */
  direction: PropTypes.oneOf([DIRECTION_TOP, DIRECTION_BOTTOM]),
  /**
   * `true` if the menu alignment should be flipped.
   */
  flipped: PropTypes.bool,
  /**
   * Enable or disable focus trap behavior
   */
  focusTrap: PropTypes.bool,
  /**
   * The CSS class for the icon.
   */
  iconClass: PropTypes.string,
  /**
   * The icon description.
   */
  iconDescription: PropTypes.string,
  /**
   * The element ID.
   */
  id: PropTypes.string,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make OverflowMenu background color same as container background color.
   */
  light: deprecate(PropTypes.bool, 'The `light` prop for `OverflowMenu` is no longer needed and has been deprecated. It will be removed in the next major release. Use the Layer component instead.'),
  /**
   * The adjustment in position applied to the floating menu.
   */
  menuOffset: PropTypes.oneOfType([PropTypes.shape({
    top: PropTypes.number,
    left: PropTypes.number
  }), PropTypes.func]),
  /**
   * The adjustment in position applied to the floating menu.
   */
  menuOffsetFlip: PropTypes.oneOfType([PropTypes.shape({
    top: PropTypes.number,
    left: PropTypes.number
  }), PropTypes.func]),
  /**
   * The class to apply to the menu options
   */
  menuOptionsClass: PropTypes.string,
  /**
   * The event handler for the `click` event.
   */
  onClick: PropTypes.func,
  /**
   * Function called when menu is closed
   */
  onClose: PropTypes.func,
  /**
   * The event handler for the `focus` event.
   */
  onFocus: PropTypes.func,
  /**
   * The event handler for the `keydown` event.
   */
  onKeyDown: PropTypes.func,
  /**
   * Function called when menu is opened
   */
  onOpen: PropTypes.func,
  /**
   * `true` if the menu should be open.
   */
  open: PropTypes.bool,
  /**
   * Function called to override icon rendering.
   */
  renderIcon: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
  /**
   * Specify a CSS selector that matches the DOM element that should
   * be focused when the OverflowMenu opens
   */
  selectorPrimaryFocus: PropTypes.string,
  /**
   * Specify the size of the OverflowMenu. Currently supports either `sm`, 'md' (default) or 'lg` as an option.
   */
  size: PropTypes.oneOf(['sm', 'md', 'lg'])
});
_defineProperty(OverflowMenu, "contextType", PrefixContext);
(() => {
  const forwardRef = (props, ref) => /*#__PURE__*/React__default.createElement(OverflowMenu, _extends({}, props, {
    innerRef: ref
  }));
  forwardRef.displayName = 'OverflowMenu';
  return /*#__PURE__*/React__default.forwardRef(forwardRef);
})();

export { OverflowMenu, getMenuOffset };
