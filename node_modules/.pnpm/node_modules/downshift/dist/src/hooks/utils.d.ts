export let useControlPropsValidator: typeof noop;
export function useScrollIntoView({ highlightedIndex, isOpen, itemRefs, getItemNodeFromIndex, menuElement, scrollIntoView: scrollIntoViewProp, }: {
    highlightedIndex: any;
    isOpen: any;
    itemRefs: any;
    getItemNodeFromIndex: any;
    menuElement: any;
    scrollIntoView: any;
}): React.MutableRefObject<boolean>;
export function useA11yMessageSetter(getA11yMessage: any, dependencyArray: any, { isInitialMount, highlightedIndex, items, environment, ...rest }: {
    [x: string]: any;
    isInitialMount: any;
    highlightedIndex: any;
    items: any;
    environment: any;
}): void;
export function useGetterPropsCalledChecker(): typeof noop;
/**
 * Reuse the movement tracking of mouse and touch events.
 *
 * @param {boolean} isOpen Whether the dropdown is open or not.
 * @param {Array<Object>} downshiftElementRefs Downshift element refs to track movement (toggleButton, menu etc.)
 * @param {Object} environment Environment where component/hook exists.
 * @param {Function} handleBlur Handler on blur from mouse or touch.
 * @returns {Object} Ref containing whether mouseDown or touchMove event is happening
 */
export function useMouseAndTouchTracker(isOpen: boolean, downshiftElementRefs: Array<Object>, environment: Object, handleBlur: Function): Object;
export function getHighlightedIndexOnOpen(props: any, state: any, offset: any): any;
export function getInitialState(props: any): {
    highlightedIndex: any;
    isOpen: any;
    selectedItem: any;
    inputValue: any;
};
export function getInitialValue(props: any, propKey: any, defaultStateValues?: {
    highlightedIndex: number;
    isOpen: boolean;
    selectedItem: null;
    inputValue: string;
}): any;
export function getDefaultValue(props: any, propKey: any, defaultStateValues?: {
    highlightedIndex: number;
    isOpen: boolean;
    selectedItem: null;
    inputValue: string;
}): any;
export namespace defaultProps {
    export { itemToString };
    export { stateReducer };
    export { getA11ySelectionMessage };
    export { scrollIntoView };
    export const environment: (Window & typeof globalThis) | undefined;
}
/**
 * Wraps the useEnhancedReducer and applies the controlled prop values before
 * returning the new state.
 *
 * @param {Function} reducer Reducer function from downshift.
 * @param {Object} initialState Initial state of the hook.
 * @param {Object} props The hook props.
 * @returns {Array} An array with the state and an action dispatcher.
 */
export function useControlledReducer(reducer: Function, initialState: Object, props: Object): any[];
/**
 * Computes the controlled state using a the previous state, props,
 * two reducers, one from downshift and an optional one from the user.
 * Also calls the onChange handlers for state values that have changed.
 *
 * @param {Function} reducer Reducer function from downshift.
 * @param {Object} initialState Initial state of the hook.
 * @param {Object} props The hook props.
 * @returns {Array} An array with the state and an action dispatcher.
 */
export function useEnhancedReducer(reducer: Function, initialState: Object, props: Object): any[];
export function useLatestRef(val: any): React.MutableRefObject<any>;
export function capitalizeString(string: any): string;
export function isAcceptedCharacterKey(key: any): boolean;
export function getItemAndIndex(itemProp: any, indexProp: any, items: any, errorMessage: any): any[];
export const useElementIds: (({ id, labelId, menuId, getItemId, toggleButtonId, inputId, }: {
    id: any;
    labelId: any;
    menuId: any;
    getItemId: any;
    toggleButtonId: any;
    inputId: any;
}) => {
    labelId: any;
    menuId: any;
    getItemId: any;
    toggleButtonId: any;
    inputId: any;
}) | (({ id, labelId, menuId, getItemId, toggleButtonId, inputId, }: {
    id?: string | undefined;
    labelId: any;
    menuId: any;
    getItemId: any;
    toggleButtonId: any;
    inputId: any;
}) => {
    labelId: any;
    menuId: any;
    getItemId: any;
    toggleButtonId: any;
    inputId: any;
});
/**
 * Handles selection on Enter / Alt + ArrowUp. Closes the menu and resets the highlighted index, unless there is a highlighted.
 * In that case, selects the item and resets to defaults for open state and highlighted idex.
 * @param {Object} props The useCombobox props.
 * @param {number} highlightedIndex The index from the state.
 * @param {boolean} inputValue Also return the input value for state.
 * @returns The changes for the state.
 */
export function getChangesOnSelection(props: Object, highlightedIndex: number, inputValue?: boolean): any;
export namespace commonDropdownPropTypes {
    export const getA11yStatusMessage: PropTypes.Requireable<(...args: any[]) => any>;
    export const highlightedIndex: PropTypes.Requireable<number>;
    export const defaultHighlightedIndex: PropTypes.Requireable<number>;
    export const initialHighlightedIndex: PropTypes.Requireable<number>;
    export const isOpen: PropTypes.Requireable<boolean>;
    export const defaultIsOpen: PropTypes.Requireable<boolean>;
    export const initialIsOpen: PropTypes.Requireable<boolean>;
    export const selectedItem: PropTypes.Requireable<any>;
    export const initialSelectedItem: PropTypes.Requireable<any>;
    export const defaultSelectedItem: PropTypes.Requireable<any>;
    export const id: PropTypes.Requireable<string>;
    export const labelId: PropTypes.Requireable<string>;
    export const menuId: PropTypes.Requireable<string>;
    export const getItemId: PropTypes.Requireable<(...args: any[]) => any>;
    export const toggleButtonId: PropTypes.Requireable<string>;
    export const onSelectedItemChange: PropTypes.Requireable<(...args: any[]) => any>;
    export const onHighlightedIndexChange: PropTypes.Requireable<(...args: any[]) => any>;
    export const onStateChange: PropTypes.Requireable<(...args: any[]) => any>;
    export const onIsOpenChange: PropTypes.Requireable<(...args: any[]) => any>;
    const scrollIntoView_1: PropTypes.Requireable<(...args: any[]) => any>;
    export { scrollIntoView_1 as scrollIntoView };
    const environment_1: PropTypes.Requireable<PropTypes.InferProps<{
        addEventListener: PropTypes.Validator<(...args: any[]) => any>;
        removeEventListener: PropTypes.Validator<(...args: any[]) => any>;
        document: PropTypes.Validator<NonNullable<PropTypes.InferProps<{
            createElement: PropTypes.Validator<(...args: any[]) => any>;
            getElementById: PropTypes.Validator<(...args: any[]) => any>;
            activeElement: PropTypes.Validator<any>;
            body: PropTypes.Validator<any>;
        }>>>;
        Node: PropTypes.Validator<(...args: any[]) => any>;
    }>>;
    export { environment_1 as environment };
    const itemToString_1: PropTypes.Requireable<(...args: any[]) => any>;
    export { itemToString_1 as itemToString };
    const stateReducer_1: PropTypes.Requireable<(...args: any[]) => any>;
    export { stateReducer_1 as stateReducer };
}
export namespace commonPropTypes { }
import { noop } from "../utils";
import React from "react";
declare function itemToString(item: any): string;
/**
 * Default state reducer that returns the changes.
 *
 * @param {Object} s state.
 * @param {Object} a action with changes.
 * @returns {Object} changes.
 */
declare function stateReducer(s: Object, a: Object): Object;
/**
 * Returns a message to be added to aria-live region when item is selected.
 *
 * @param {Object} selectionParameters Parameters required to build the message.
 * @returns {string} The a11y message.
 */
declare function getA11ySelectionMessage(selectionParameters: Object): string;
import { scrollIntoView } from "../utils";
import PropTypes from "prop-types";
export {};
