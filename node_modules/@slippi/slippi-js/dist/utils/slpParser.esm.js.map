{"version":3,"file":"slpParser.esm.js","sources":["../../src/utils/slpParser.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\nimport { get, keyBy, set } from \"lodash\";\nimport semver from \"semver\";\n\nimport type {\n  FrameBookendType,\n  FrameEntryType,\n  FramesType,\n  GameEndType,\n  GameStartType,\n  ItemUpdateType,\n  PostFrameUpdateType,\n  PreFrameUpdateType,\n  RollbackFrames,\n} from \"../types\";\nimport { Command, Frames, GameMode } from \"../types\";\nimport { RollbackCounter } from \"./rollbackCounter\";\n\nexport const MAX_ROLLBACK_FRAMES = 7;\n\nexport enum SlpParserEvent {\n  SETTINGS = \"settings\",\n  END = \"end\",\n  FRAME = \"frame\", // Emitted for every frame\n  FINALIZED_FRAME = \"finalized-frame\", // Emitted for only finalized frames\n  ROLLBACK_FRAME = \"rollback-frame\", // Emitted if a frame is being replaced\n}\n\n// If strict mode is on, we will do strict validation checking\n// which could throw errors on invalid data.\n// Default to false though since probably only real time applications\n// would care about valid data.\nconst defaultSlpParserOptions = {\n  strict: false,\n};\n\nexport type SlpParserOptions = typeof defaultSlpParserOptions;\n\nexport class SlpParser extends EventEmitter {\n  private frames: FramesType = {};\n  private rollbackCounter: RollbackCounter = new RollbackCounter();\n  private settings: GameStartType | null = null;\n  private gameEnd: GameEndType | null = null;\n  private latestFrameIndex: number | null = null;\n  private settingsComplete = false;\n  private lastFinalizedFrame = Frames.FIRST - 1;\n  private options: SlpParserOptions;\n\n  public constructor(options?: Partial<SlpParserOptions>) {\n    super();\n    this.options = Object.assign({}, defaultSlpParserOptions, options);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public handleCommand(command: Command, payload: any): void {\n    switch (command) {\n      case Command.GAME_START:\n        this._handleGameStart(payload as GameStartType);\n        break;\n      case Command.POST_FRAME_UPDATE:\n        // We need to handle the post frame update first since that\n        // will finalize the settings object, before we fire the frame update\n        this._handlePostFrameUpdate(payload as PostFrameUpdateType);\n        this._handleFrameUpdate(command, payload as PostFrameUpdateType);\n        break;\n      case Command.PRE_FRAME_UPDATE:\n        this._handleFrameUpdate(command, payload as PreFrameUpdateType);\n        break;\n      case Command.ITEM_UPDATE:\n        this._handleItemUpdate(payload as ItemUpdateType);\n        break;\n      case Command.FRAME_BOOKEND:\n        this._handleFrameBookend(payload as FrameBookendType);\n        break;\n      case Command.GAME_END:\n        this._handleGameEnd(payload as GameEndType);\n        break;\n    }\n  }\n\n  /**\n   * Resets the parser state to their default values.\n   */\n  public reset(): void {\n    this.frames = {};\n    this.settings = null;\n    this.gameEnd = null;\n    this.latestFrameIndex = null;\n    this.settingsComplete = false;\n    this.lastFinalizedFrame = Frames.FIRST - 1;\n  }\n\n  public getLatestFrameNumber(): number {\n    return this.latestFrameIndex ?? Frames.FIRST - 1;\n  }\n\n  public getPlayableFrameCount(): number {\n    if (this.latestFrameIndex === null) {\n      return 0;\n    }\n    return this.latestFrameIndex < Frames.FIRST_PLAYABLE ? 0 : this.latestFrameIndex - Frames.FIRST_PLAYABLE;\n  }\n\n  public getLatestFrame(): FrameEntryType | null {\n    // return this.playerFrames[this.latestFrameIndex];\n\n    // TODO: Modify this to check if we actually have all the latest frame data and return that\n    // TODO: If we do. For now I'm just going to take a shortcut\n    const allFrames = this.getFrames();\n    const frameIndex = this.latestFrameIndex !== null ? this.latestFrameIndex : Frames.FIRST;\n    const indexToUse = this.gameEnd ? frameIndex : frameIndex - 1;\n    return get(allFrames, indexToUse) || null;\n  }\n\n  public getSettings(): GameStartType | null {\n    return this.settingsComplete ? this.settings : null;\n  }\n\n  public getGameEnd(): GameEndType | null {\n    return this.gameEnd;\n  }\n\n  public getFrames(): FramesType {\n    return this.frames;\n  }\n\n  public getRollbackFrames(): RollbackFrames {\n    return {\n      frames: this.rollbackCounter.getFrames(),\n      count: this.rollbackCounter.getCount(),\n      lengths: this.rollbackCounter.getLengths(),\n    };\n  }\n\n  public getFrame(num: number): FrameEntryType | null {\n    return this.frames[num] || null;\n  }\n\n  private _handleGameEnd(payload: GameEndType): void {\n    // Finalize remaining frames if necessary\n    if (this.latestFrameIndex !== null && this.latestFrameIndex !== this.lastFinalizedFrame) {\n      this._finalizeFrames(this.latestFrameIndex);\n    }\n\n    payload = payload as GameEndType;\n    this.gameEnd = payload;\n    this.emit(SlpParserEvent.END, this.gameEnd);\n  }\n\n  private _handleGameStart(payload: GameStartType): void {\n    this.settings = payload;\n    const players = payload.players;\n    this.settings.players = players.filter((player) => player.type !== 3);\n\n    // Check to see if the file was created after the sheik fix so we know\n    // we don't have to process the first frame of the game for the full settings\n    if (payload.slpVersion && semver.gte(payload.slpVersion, \"1.6.0\")) {\n      this._completeSettings();\n    }\n  }\n\n  private _handlePostFrameUpdate(payload: PostFrameUpdateType): void {\n    if (this.settingsComplete) {\n      return;\n    }\n\n    // Finish calculating settings\n    if (payload.frame! <= Frames.FIRST) {\n      const playerIndex = payload.playerIndex!;\n      const playersByIndex = keyBy(this.settings!.players, \"playerIndex\");\n\n      switch (payload.internalCharacterId) {\n        case 0x7:\n          playersByIndex[playerIndex]!.characterId = 0x13; // Sheik\n          break;\n        case 0x13:\n          playersByIndex[playerIndex]!.characterId = 0x12; // Zelda\n          break;\n      }\n    }\n    if (payload.frame! > Frames.FIRST) {\n      this._completeSettings();\n    }\n  }\n\n  private _handleFrameUpdate(command: Command, payload: PreFrameUpdateType | PostFrameUpdateType): void {\n    payload = payload as PostFrameUpdateType;\n    const location = command === Command.PRE_FRAME_UPDATE ? \"pre\" : \"post\";\n    const field = payload.isFollower ? \"followers\" : \"players\";\n    const currentFrameNumber = payload.frame!;\n    this.latestFrameIndex = currentFrameNumber;\n    if (location === \"pre\" && !payload.isFollower) {\n      const currentFrame = this.frames[currentFrameNumber];\n      const wasRolledback = this.rollbackCounter.checkIfRollbackFrame(currentFrame, payload.playerIndex!);\n      if (wasRolledback) {\n        // frame is about to be overwritten\n        this.emit(SlpParserEvent.ROLLBACK_FRAME, currentFrame);\n      }\n    }\n    set(this.frames, [currentFrameNumber, field, payload.playerIndex!, location], payload);\n    set(this.frames, [currentFrameNumber, \"frame\"], currentFrameNumber);\n\n    // If file is from before frame bookending, add frame to stats computer here. Does a little\n    // more processing than necessary, but it works\n    const settings = this.getSettings();\n    if (settings && (!settings.slpVersion || semver.lte(settings.slpVersion, \"2.2.0\"))) {\n      this.emit(SlpParserEvent.FRAME, this.frames[currentFrameNumber]);\n      // Finalize the previous frame since no bookending exists\n      this._finalizeFrames(currentFrameNumber - 1);\n    } else {\n      set(this.frames, [currentFrameNumber, \"isTransferComplete\"], false);\n    }\n  }\n\n  private _handleItemUpdate(payload: ItemUpdateType): void {\n    const currentFrameNumber = payload.frame!;\n    const items = this.frames[currentFrameNumber]?.items ?? [];\n    items.push(payload);\n\n    // Set items with newest\n    set(this.frames, [currentFrameNumber, \"items\"], items);\n  }\n\n  private _handleFrameBookend(payload: FrameBookendType): void {\n    const latestFinalizedFrame = payload.latestFinalizedFrame!;\n    const currentFrameNumber = payload.frame!;\n    set(this.frames, [currentFrameNumber, \"isTransferComplete\"], true);\n    // Fire off a normal frame event\n    this.emit(SlpParserEvent.FRAME, this.frames[currentFrameNumber]);\n\n    // Finalize frames if necessary\n    const validLatestFrame = this.settings!.gameMode === GameMode.ONLINE;\n    if (validLatestFrame && latestFinalizedFrame >= Frames.FIRST) {\n      // Ensure valid latestFinalizedFrame\n      if (this.options.strict && latestFinalizedFrame < currentFrameNumber - MAX_ROLLBACK_FRAMES) {\n        throw new Error(`latestFinalizedFrame should be within ${MAX_ROLLBACK_FRAMES} frames of ${currentFrameNumber}`);\n      }\n      this._finalizeFrames(latestFinalizedFrame);\n    } else {\n      // Since we don't have a valid finalized frame, just finalize the frame based on MAX_ROLLBACK_FRAMES\n      this._finalizeFrames(currentFrameNumber - MAX_ROLLBACK_FRAMES);\n    }\n  }\n\n  /**\n   * Fires off the FINALIZED_FRAME event for frames up until a certain number\n   * @param num The frame to finalize until\n   */\n  private _finalizeFrames(num: number): void {\n    while (this.lastFinalizedFrame < num) {\n      const frameToFinalize = this.lastFinalizedFrame + 1;\n      const frame = this.getFrame(frameToFinalize)!;\n\n      // Check that we have all the pre and post frame data for all players if we're in strict mode\n      if (this.options.strict) {\n        for (const player of this.settings!.players) {\n          const playerFrameInfo = frame.players[player.playerIndex];\n          // Allow player frame info to be empty in non 1v1 games since\n          // players which have been defeated will have no frame info.\n          if (this.settings!.players.length > 2 && !playerFrameInfo) {\n            continue;\n          }\n\n          const { pre, post } = playerFrameInfo!;\n          if (!pre || !post) {\n            const preOrPost = pre ? \"pre\" : \"post\";\n            throw new Error(\n              `Could not finalize frame ${frameToFinalize} of ${num}: missing ${preOrPost}-frame update for player ${player.playerIndex}`,\n            );\n          }\n        }\n      }\n\n      // Our frame is complete so finalize the frame\n      this.emit(SlpParserEvent.FINALIZED_FRAME, frame);\n      this.lastFinalizedFrame = frameToFinalize;\n    }\n  }\n\n  private _completeSettings(): void {\n    if (!this.settingsComplete) {\n      this.settingsComplete = true;\n      this.emit(SlpParserEvent.SETTINGS, this.settings);\n    }\n  }\n}\n"],"names":["MAX_ROLLBACK_FRAMES","SlpParserEvent","defaultSlpParserOptions","strict","SlpParser","EventEmitter","constructor","options","frames","rollbackCounter","RollbackCounter","settings","gameEnd","latestFrameIndex","settingsComplete","lastFinalizedFrame","Frames","FIRST","Object","assign","handleCommand","command","payload","Command","GAME_START","_handleGameStart","POST_FRAME_UPDATE","_handlePostFrameUpdate","_handleFrameUpdate","PRE_FRAME_UPDATE","ITEM_UPDATE","_handleItemUpdate","FRAME_BOOKEND","_handleFrameBookend","GAME_END","_handleGameEnd","reset","getLatestFrameNumber","getPlayableFrameCount","FIRST_PLAYABLE","getLatestFrame","allFrames","getFrames","frameIndex","indexToUse","get","getSettings","getGameEnd","getRollbackFrames","count","getCount","lengths","getLengths","getFrame","num","_finalizeFrames","emit","END","players","filter","player","type","slpVersion","semver","gte","_completeSettings","frame","playerIndex","playersByIndex","keyBy","internalCharacterId","characterId","location","field","isFollower","currentFrameNumber","currentFrame","wasRolledback","checkIfRollbackFrame","ROLLBACK_FRAME","set","lte","FRAME","items","push","latestFinalizedFrame","validLatestFrame","gameMode","GameMode","ONLINE","Error","frameToFinalize","playerFrameInfo","length","pre","post","preOrPost","FINALIZED_FRAME","SETTINGS"],"mappings":"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"}