{"version":3,"file":"slpStream.esm.js","sources":["../../src/utils/slpStream.ts"],"sourcesContent":["import type { WritableOptions } from \"stream\";\nimport { Writable } from \"stream\";\n\nimport { NETWORK_MESSAGE } from \"../console\";\nimport type { EventPayloadTypes } from \"../types\";\nimport { Command } from \"../types\";\nimport { parseMessage } from \"./slpReader\";\n\nexport enum SlpStreamMode {\n  AUTO = \"AUTO\", // Always reading data, but errors on invalid command\n  MANUAL = \"MANUAL\", // Stops parsing inputs after a valid game end command, requires manual restarting\n}\n\nconst defaultSettings = {\n  suppressErrors: false,\n  mode: SlpStreamMode.AUTO,\n};\n\nexport type SlpStreamSettings = typeof defaultSettings;\n\nexport type MessageSizes = Map<Command, number>;\n\nexport interface SlpCommandEventPayload {\n  command: Command;\n  payload: EventPayloadTypes | MessageSizes;\n}\n\nexport interface SlpRawEventPayload {\n  command: Command;\n  payload: Buffer;\n}\n\nexport enum SlpStreamEvent {\n  RAW = \"slp-raw\",\n  COMMAND = \"slp-command\",\n}\n\n/**\n * SlpStream is a writable stream of Slippi data. It passes the data being written in\n * and emits an event based on what kind of Slippi messages were processed.\n *\n * SlpStream emits two events: \"slp-raw\" and \"slp-command\". The \"slp-raw\" event emits the raw buffer\n * bytes whenever it processes each command. You can manually parse this or write it to a\n * file. The \"slp-command\" event returns the parsed payload which you can access the attributes.\n *\n * @class SlpStream\n * @extends {Writable}\n */\nexport class SlpStream extends Writable {\n  private gameEnded = false; // True only if in manual mode and the game has completed\n  private settings: SlpStreamSettings;\n  private payloadSizes: MessageSizes | null = null;\n  private previousBuffer: Uint8Array = Buffer.from([]);\n\n  /**\n   *Creates an instance of SlpStream.\n   * @param {Partial<SlpStreamSettings>} [slpOptions]\n   * @param {WritableOptions} [opts]\n   * @memberof SlpStream\n   */\n  public constructor(slpOptions?: Partial<SlpStreamSettings>, opts?: WritableOptions) {\n    super(opts);\n    this.settings = Object.assign({}, defaultSettings, slpOptions);\n  }\n\n  public restart(): void {\n    this.gameEnded = false;\n    this.payloadSizes = null;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public _write(newData: Buffer, encoding: string, callback: (error?: Error | null, data?: any) => void): void {\n    if (encoding !== \"buffer\") {\n      throw new Error(`Unsupported stream encoding. Expected 'buffer' got '${encoding}'.`);\n    }\n\n    // Join the current data with the old data\n    const data = Uint8Array.from(Buffer.concat([this.previousBuffer, newData]));\n\n    // Clear previous data\n    this.previousBuffer = Buffer.from([]);\n\n    const dataView = new DataView(data.buffer);\n\n    // Iterate through the data\n    let index = 0;\n    while (index < data.length) {\n      // We want to filter out the network messages\n      if (Buffer.from(data.slice(index, index + 5)).toString() === NETWORK_MESSAGE) {\n        index += 5;\n        continue;\n      }\n\n      // Make sure we have enough data to read a full payload\n      const command = dataView.getUint8(index);\n      let payloadSize = 0;\n      if (this.payloadSizes) {\n        payloadSize = this.payloadSizes.get(command) ?? 0;\n      }\n      const remainingLen = data.length - index;\n      if (remainingLen < payloadSize + 1) {\n        // If remaining length is not long enough for full payload, save the remaining\n        // data until we receive more data. The data has been split up.\n        this.previousBuffer = data.slice(index);\n        break;\n      }\n\n      // Only process if the game is still going\n      if (this.settings.mode === SlpStreamMode.MANUAL && this.gameEnded) {\n        break;\n      }\n\n      // Increment by one for the command byte\n      index += 1;\n\n      const payloadPtr = data.slice(index);\n      const payloadDataView = new DataView(data.buffer, index);\n      let payloadLen = 0;\n      try {\n        payloadLen = this._processCommand(command, payloadPtr, payloadDataView);\n      } catch (err) {\n        // Only throw the error if we're not suppressing the errors\n        if (!this.settings.suppressErrors) {\n          throw err;\n        }\n        payloadLen = 0;\n      }\n      index += payloadLen;\n    }\n\n    callback();\n  }\n\n  private _writeCommand(command: Command, entirePayload: Uint8Array, payloadSize: number): Uint8Array {\n    const payloadBuf = entirePayload.slice(0, payloadSize);\n    const bufToWrite = Buffer.concat([Buffer.from([command]), payloadBuf]);\n    // Forward the raw buffer onwards\n    this.emit(SlpStreamEvent.RAW, {\n      command: command,\n      payload: bufToWrite,\n    } as SlpRawEventPayload);\n    return new Uint8Array(bufToWrite);\n  }\n\n  private _processCommand(command: Command, entirePayload: Uint8Array, dataView: DataView): number {\n    // Handle the message size command\n    if (command === Command.MESSAGE_SIZES) {\n      const payloadSize = dataView.getUint8(0);\n      // Set the payload sizes\n      this.payloadSizes = processReceiveCommands(dataView);\n      // Emit the raw command event\n      this._writeCommand(command, entirePayload, payloadSize);\n      this.emit(SlpStreamEvent.COMMAND, {\n        command: command,\n        payload: this.payloadSizes,\n      } as SlpCommandEventPayload);\n      return payloadSize;\n    }\n\n    let payloadSize = 0;\n    if (this.payloadSizes) {\n      payloadSize = this.payloadSizes.get(command) ?? 0;\n    }\n\n    // Fetch the payload and parse it\n    let payload: Uint8Array;\n    let parsedPayload: EventPayloadTypes | null = null;\n    if (payloadSize > 0) {\n      payload = this._writeCommand(command, entirePayload, payloadSize);\n      parsedPayload = parseMessage(command, payload);\n    }\n    if (!parsedPayload) {\n      return payloadSize;\n    }\n\n    switch (command) {\n      case Command.GAME_END:\n        // Stop parsing data until we manually restart the stream\n        if (this.settings.mode === SlpStreamMode.MANUAL) {\n          this.gameEnded = true;\n        }\n        break;\n    }\n\n    this.emit(SlpStreamEvent.COMMAND, {\n      command: command,\n      payload: parsedPayload,\n    } as SlpCommandEventPayload);\n    return payloadSize;\n  }\n}\n\nconst processReceiveCommands = (dataView: DataView): MessageSizes => {\n  const payloadSizes = new Map<Command, number>();\n  const payloadLen = dataView.getUint8(0);\n  for (let i = 1; i < payloadLen; i += 3) {\n    const commandByte = dataView.getUint8(i);\n    const payloadSize = dataView.getUint16(i + 1);\n    payloadSizes.set(commandByte, payloadSize);\n  }\n  return payloadSizes;\n};\n"],"names":["SlpStreamMode","defaultSettings","suppressErrors","mode","AUTO","SlpStreamEvent","SlpStream","Writable","constructor","slpOptions","opts","gameEnded","settings","payloadSizes","previousBuffer","Buffer","from","Object","assign","restart","_write","newData","encoding","callback","Error","data","Uint8Array","concat","dataView","DataView","buffer","index","length","slice","toString","NETWORK_MESSAGE","command","getUint8","payloadSize","get","remainingLen","MANUAL","payloadPtr","payloadDataView","payloadLen","_processCommand","err","_writeCommand","entirePayload","payloadBuf","bufToWrite","emit","RAW","payload","Command","MESSAGE_SIZES","processReceiveCommands","COMMAND","parsedPayload","parseMessage","GAME_END","Map","i","commandByte","getUint16","set"],"mappings":"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"}