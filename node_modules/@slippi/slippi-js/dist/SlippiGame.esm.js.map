{"version":3,"file":"SlippiGame.esm.js","sources":["../src/SlippiGame.ts"],"sourcesContent":["import type { StadiumStatsType, StatOptions, StatsType } from \"./stats\";\nimport { TargetBreakComputer } from \"./stats\";\nimport {\n  ActionsComputer,\n  ComboComputer,\n  ConversionComputer,\n  generateOverallStats,\n  InputComputer,\n  Stats,\n  StockComputer,\n} from \"./stats\";\nimport type {\n  EnabledItemType,\n  EventCallbackFunc,\n  FrameEntryType,\n  FramesType,\n  GameEndType,\n  GameStartType,\n  GeckoListType,\n  MetadataType,\n  PlacementType,\n  PostFrameUpdateType,\n  RollbackFrames,\n} from \"./types\";\nimport { GameEndMethod, GameMode } from \"./types\";\nimport { getWinners } from \"./utils/getWinners\";\nimport { extractDistanceInfoFromFrame } from \"./utils/homeRunDistance\";\nimport { SlpParser, SlpParserEvent } from \"./utils/slpParser\";\nimport type { SlpFileType, SlpReadInput } from \"./utils/slpReader\";\nimport {\n  closeSlpFile,\n  extractFinalPostFrameUpdates,\n  getGameEnd,\n  getMetadata,\n  iterateEvents,\n  openSlpFile,\n  SlpInputSource,\n} from \"./utils/slpReader\";\n\n/**\n * Slippi Game class that wraps a file\n */\nexport class SlippiGame {\n  private input: SlpReadInput;\n  private metadata: MetadataType | null = null;\n  private finalStats: StatsType | null = null;\n  private parser: SlpParser;\n  private readPosition: number | null = null;\n  private actionsComputer: ActionsComputer = new ActionsComputer();\n  private conversionComputer: ConversionComputer = new ConversionComputer();\n  private comboComputer: ComboComputer = new ComboComputer();\n  private stockComputer: StockComputer = new StockComputer();\n  private inputComputer: InputComputer = new InputComputer();\n  private targetBreakComputer: TargetBreakComputer = new TargetBreakComputer();\n  protected statsComputer: Stats;\n\n  public constructor(input: string | Buffer | ArrayBuffer, opts?: StatOptions) {\n    if (typeof input === \"string\") {\n      this.input = {\n        source: SlpInputSource.FILE,\n        filePath: input,\n      };\n    } else if (input instanceof Buffer) {\n      this.input = {\n        source: SlpInputSource.BUFFER,\n        buffer: input,\n      };\n    } else if (input instanceof ArrayBuffer) {\n      this.input = {\n        source: SlpInputSource.BUFFER,\n        buffer: Buffer.from(input),\n      };\n    } else {\n      throw new Error(\"Cannot create SlippiGame with input of that type\");\n    }\n\n    // Set up stats calculation\n    this.statsComputer = new Stats(opts);\n    this.statsComputer.register(\n      this.actionsComputer,\n      this.comboComputer,\n      this.conversionComputer,\n      this.inputComputer,\n      this.stockComputer,\n      this.targetBreakComputer,\n    );\n\n    this.parser = new SlpParser();\n    this.parser.on(SlpParserEvent.SETTINGS, (settings) => {\n      this.statsComputer.setup(settings);\n    });\n\n    // Use finalized frames for stats computation\n    this.parser.on(SlpParserEvent.FINALIZED_FRAME, (frame: FrameEntryType) => {\n      this.statsComputer.addFrame(frame);\n    });\n  }\n\n  private _process(shouldStop: EventCallbackFunc = () => false, file?: SlpFileType): void {\n    if (this.parser.getGameEnd() !== null) {\n      return;\n    }\n    const slpfile = file ?? openSlpFile(this.input);\n    // Generate settings from iterating through file\n    this.readPosition = iterateEvents(\n      slpfile,\n      (command, payload) => {\n        if (!payload) {\n          // If payload is falsy, keep iterating. The parser probably just doesn't know\n          // about this command yet\n          return false;\n        }\n        this.parser.handleCommand(command, payload);\n        return shouldStop(command, payload);\n      },\n      this.readPosition,\n    );\n    if (!file) {\n      closeSlpFile(slpfile);\n    }\n  }\n\n  /**\n   * Gets the game settings, these are the settings that describe the starting state of\n   * the game such as characters, stage, etc.\n   */\n  public getSettings(): GameStartType | null {\n    // Settings is only complete after post-frame update\n    this._process(() => this.parser.getSettings() !== null);\n    return this.parser.getSettings();\n  }\n\n  public getItems(): EnabledItemType[] | null {\n    this._process();\n    return this.parser.getItems();\n  }\n\n  public getLatestFrame(): FrameEntryType | null {\n    this._process();\n    return this.parser.getLatestFrame();\n  }\n\n  public getGameEnd(options: { skipProcessing?: boolean } = {}): GameEndType | null {\n    if (options?.skipProcessing) {\n      // Read game end block directly\n      const slpfile = openSlpFile(this.input);\n      const gameEnd = getGameEnd(slpfile);\n      closeSlpFile(slpfile);\n      return gameEnd;\n    }\n\n    this._process();\n    return this.parser.getGameEnd();\n  }\n\n  public getFrames(): FramesType {\n    this._process();\n    return this.parser.getFrames();\n  }\n\n  public getRollbackFrames(): RollbackFrames {\n    this._process();\n    return this.parser.getRollbackFrames();\n  }\n\n  public getGeckoList(): GeckoListType | null {\n    this._process(() => this.parser.getGeckoList() !== null);\n    return this.parser.getGeckoList();\n  }\n\n  public getStats(): StatsType | null {\n    if (this.finalStats) {\n      return this.finalStats;\n    }\n\n    this._process();\n\n    const settings = this.parser.getSettings();\n    if (!settings) {\n      return null;\n    }\n\n    // Finish processing if we're not up to date\n    this.statsComputer.process();\n    const inputs = this.inputComputer.fetch();\n    const stocks = this.stockComputer.fetch();\n    const conversions = this.conversionComputer.fetch();\n    const playableFrameCount = this.parser.getPlayableFrameCount();\n    const overall = generateOverallStats({ settings, inputs, conversions, playableFrameCount });\n\n    const gameEnd = this.parser.getGameEnd();\n    const gameComplete = gameEnd !== null;\n\n    const stats: StatsType = {\n      lastFrame: this.parser.getLatestFrameNumber(),\n      playableFrameCount,\n      stocks: stocks,\n      conversions: conversions,\n      combos: this.comboComputer.fetch(),\n      actionCounts: this.actionsComputer.fetch(),\n      overall: overall,\n      gameComplete,\n    };\n\n    if (gameComplete) {\n      // If the game is complete, store a cached version of stats because it should not\n      // change anymore. Ideally the statsCompuer.process and fetch functions would simply do no\n      // work in this case instead but currently the conversions fetch function,\n      // generateOverallStats, and maybe more are doing work on every call.\n      this.finalStats = stats;\n    }\n\n    return stats;\n  }\n\n  public getStadiumStats(): StadiumStatsType | null {\n    this._process();\n\n    const settings = this.parser.getSettings();\n    if (!settings) {\n      return null;\n    }\n\n    const latestFrame = this.parser.getLatestFrame();\n    const players = latestFrame?.players;\n\n    if (!players) {\n      return null;\n    }\n\n    this.statsComputer.process();\n\n    switch (settings.gameMode) {\n      case GameMode.TARGET_TEST:\n        return {\n          type: \"target-test\",\n          targetBreaks: this.targetBreakComputer.fetch(),\n        };\n      case GameMode.HOME_RUN_CONTEST:\n        const distanceInfo = extractDistanceInfoFromFrame(settings, latestFrame);\n        if (!distanceInfo) {\n          return null;\n        }\n\n        return {\n          type: \"home-run-contest\",\n          distance: distanceInfo.distance,\n          units: distanceInfo.units,\n        };\n      default:\n        return null;\n    }\n  }\n\n  public getMetadata(): MetadataType | null {\n    if (this.metadata) {\n      return this.metadata;\n    }\n    const slpfile = openSlpFile(this.input);\n    this.metadata = getMetadata(slpfile);\n    closeSlpFile(slpfile);\n    return this.metadata;\n  }\n\n  public getFilePath(): string | null {\n    if (this.input.source !== SlpInputSource.FILE) {\n      return null;\n    }\n\n    return this.input.filePath ?? null;\n  }\n\n  public getWinners(): PlacementType[] {\n    // Read game end block directly\n    const slpfile = openSlpFile(this.input);\n    const gameEnd = getGameEnd(slpfile);\n    this._process(() => this.parser.getSettings() !== null, slpfile);\n    const settings = this.parser.getSettings();\n    if (!gameEnd || !settings) {\n      // Technically using the final post frame updates, it should be possible to compute winners for\n      // replays without a gameEnd message. But I'll leave this here anyway\n      closeSlpFile(slpfile);\n      return [];\n    }\n\n    // If we went to time, let's fetch the post frame updates to compute the winner\n    let finalPostFrameUpdates: PostFrameUpdateType[] = [];\n    if (gameEnd.gameEndMethod === GameEndMethod.TIME) {\n      finalPostFrameUpdates = extractFinalPostFrameUpdates(slpfile);\n    }\n\n    closeSlpFile(slpfile);\n    return getWinners(gameEnd, settings, finalPostFrameUpdates);\n  }\n}\n"],"names":["SlippiGame","constructor","input","opts","metadata","finalStats","parser","readPosition","actionsComputer","ActionsComputer","conversionComputer","ConversionComputer","comboComputer","ComboComputer","stockComputer","StockComputer","inputComputer","InputComputer","targetBreakComputer","TargetBreakComputer","statsComputer","source","SlpInputSource","FILE","filePath","Buffer","BUFFER","buffer","ArrayBuffer","from","Error","Stats","register","SlpParser","on","SlpParserEvent","SETTINGS","settings","setup","FINALIZED_FRAME","frame","addFrame","_process","shouldStop","file","getGameEnd","slpfile","openSlpFile","iterateEvents","command","payload","handleCommand","closeSlpFile","getSettings","getItems","getLatestFrame","options","skipProcessing","gameEnd","getFrames","getRollbackFrames","getGeckoList","getStats","process","inputs","fetch","stocks","conversions","playableFrameCount","getPlayableFrameCount","overall","generateOverallStats","gameComplete","stats","lastFrame","getLatestFrameNumber","combos","actionCounts","getStadiumStats","latestFrame","players","gameMode","GameMode","TARGET_TEST","type","targetBreaks","HOME_RUN_CONTEST","distanceInfo","extractDistanceInfoFromFrame","distance","units","getMetadata","getFilePath","getWinners","finalPostFrameUpdates","gameEndMethod","GameEndMethod","TIME","extractFinalPostFrameUpdates"],"mappings":"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"}