{"version":3,"file":"conversions.esm.js","sources":["../../src/stats/conversions.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\nimport { filter, get, groupBy, last, orderBy } from \"lodash\";\n\nimport type { FrameEntryType, FramesType, GameStartType, PostFrameUpdateType } from \"../types\";\nimport type { ConversionType, MoveLandedType, PlayerIndexedType } from \"./common\";\nimport {\n  calcDamageTaken,\n  didLoseStock,\n  getSinglesPlayerPermutationsFromSettings,\n  isCommandGrabbed,\n  isDamaged,\n  isGrabbed,\n  isInControl,\n  Timers,\n} from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\ninterface PlayerConversionState {\n  conversion: ConversionType | null;\n  move: MoveLandedType | null;\n  resetCounter: number;\n  lastHitAnimation: number | null;\n}\n\ninterface MetadataType {\n  lastEndFrameByOppIdx: {\n    [oppIdx: number]: number;\n  };\n}\n\nexport class ConversionComputer extends EventEmitter implements StatComputer<ConversionType[]> {\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private conversions = new Array<ConversionType>();\n  private state = new Map<PlayerIndexedType, PlayerConversionState>();\n  private metadata: MetadataType;\n  private settings: GameStartType | null = null;\n\n  public constructor() {\n    super();\n    this.metadata = {\n      lastEndFrameByOppIdx: {},\n    };\n  }\n\n  public setup(settings: GameStartType): void {\n    // Reset the state\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.conversions = [];\n    this.state = new Map();\n    this.metadata = {\n      lastEndFrameByOppIdx: {},\n    };\n    this.settings = settings;\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: PlayerConversionState = {\n        conversion: null,\n        move: null,\n        resetCounter: 0,\n        lastHitAnimation: null,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        const terminated = handleConversionCompute(allFrames, state, indices, frame, this.conversions);\n        if (terminated) {\n          this.emit(\"CONVERSION\", {\n            combo: last(this.conversions),\n            settings: this.settings,\n          });\n        }\n      }\n    });\n  }\n\n  public fetch(): ConversionType[] {\n    this._populateConversionTypes();\n    return this.conversions;\n  }\n\n  private _populateConversionTypes(): void {\n    // Post-processing step: set the openingTypes\n    const conversionsToHandle = filter(this.conversions, (conversion) => {\n      return conversion.openingType === \"unknown\";\n    });\n\n    // Group new conversions by startTime and sort\n    const groupedConversions = groupBy(conversionsToHandle, \"startFrame\");\n    const sortedConversions = orderBy(groupedConversions, (conversions) => get(conversions, [0, \"startFrame\"]));\n\n    // Set the opening types on the conversions we need to handle\n    sortedConversions.forEach((conversions) => {\n      const isTrade = conversions.length >= 2;\n      conversions.forEach((conversion) => {\n        // Set end frame for this conversion\n        this.metadata.lastEndFrameByOppIdx[conversion.playerIndex] = conversion.endFrame!;\n\n        if (isTrade) {\n          // If trade, just short-circuit\n          conversion.openingType = \"trade\";\n          return;\n        }\n\n        // If not trade, check the opponent endFrame\n        const lastMove = last(conversion.moves);\n        const oppEndFrame =\n          this.metadata.lastEndFrameByOppIdx[lastMove ? lastMove.playerIndex : conversion.playerIndex];\n        const isCounterAttack = oppEndFrame && oppEndFrame > conversion.startFrame;\n        conversion.openingType = isCounterAttack ? \"counter-attack\" : \"neutral-win\";\n      });\n    });\n  }\n}\n\nfunction handleConversionCompute(\n  frames: FramesType,\n  state: PlayerConversionState,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n  conversions: ConversionType[],\n): boolean {\n  const currentFrameNumber = frame.frame;\n  const playerFrame: PostFrameUpdateType = frame.players[indices.playerIndex]!.post;\n  const opponentFrame = frame.players[indices.opponentIndex]!.post;\n\n  const prevFrameNumber = currentFrameNumber - 1;\n  let prevPlayerFrame: PostFrameUpdateType | null = null;\n  let prevOpponentFrame: PostFrameUpdateType | null = null;\n\n  if (frames[prevFrameNumber]) {\n    prevPlayerFrame = frames[prevFrameNumber]!.players[indices.playerIndex]!.post;\n    prevOpponentFrame = frames[prevFrameNumber]!.players[indices.opponentIndex]!.post;\n  }\n\n  const oppActionStateId = opponentFrame.actionStateId!;\n  const opntIsDamaged = isDamaged(oppActionStateId);\n  const opntIsGrabbed = isGrabbed(oppActionStateId);\n  const opntIsCommandGrabbed = isCommandGrabbed(oppActionStateId);\n  const opntDamageTaken = prevOpponentFrame ? calcDamageTaken(opponentFrame, prevOpponentFrame) : 0;\n\n  // Keep track of whether actionState changes after a hit. Used to compute move count\n  // When purely using action state there was a bug where if you did two of the same\n  // move really fast (such as ganon's jab), it would count as one move. Added\n  // the actionStateCounter at this point which counts the number of frames since\n  // an animation started. Should be more robust, for old files it should always be\n  // null and null < null = false\n  const actionChangedSinceHit = playerFrame.actionStateId !== state.lastHitAnimation;\n  const actionCounter = playerFrame.actionStateCounter!;\n  const prevActionCounter = prevPlayerFrame ? prevPlayerFrame.actionStateCounter! : 0;\n  const actionFrameCounterReset = actionCounter < prevActionCounter;\n  if (actionChangedSinceHit || actionFrameCounterReset) {\n    state.lastHitAnimation = null;\n  }\n\n  // If opponent took damage and was put in some kind of stun this frame, either\n  // start a conversion or\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    if (!state.conversion) {\n      state.conversion = {\n        playerIndex: indices.opponentIndex,\n        lastHitBy: indices.playerIndex,\n        startFrame: currentFrameNumber,\n        endFrame: null,\n        startPercent: prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0,\n        currentPercent: opponentFrame.percent ?? 0,\n        endPercent: null,\n        moves: [],\n        didKill: false,\n        openingType: \"unknown\", // Will be updated later\n      };\n\n      conversions.push(state.conversion);\n    }\n\n    if (opntDamageTaken) {\n      // If animation of last hit has been cleared that means this is a new move. This\n      // prevents counting multiple hits from the same move such as fox's drill\n      if (state.lastHitAnimation === null) {\n        state.move = {\n          playerIndex: indices.playerIndex,\n          frame: currentFrameNumber,\n          moveId: playerFrame.lastAttackLanded!,\n          hitCount: 0,\n          damage: 0,\n        };\n\n        state.conversion.moves.push(state.move);\n      }\n\n      if (state.move) {\n        state.move.hitCount += 1;\n        state.move.damage += opntDamageTaken;\n      }\n\n      // Store previous frame animation to consider the case of a trade, the previous\n      // frame should always be the move that actually connected... I hope\n      state.lastHitAnimation = prevPlayerFrame ? prevPlayerFrame.actionStateId : null;\n    }\n  }\n\n  if (!state.conversion) {\n    // The rest of the function handles conversion termination logic, so if we don't\n    // have a conversion started, there is no need to continue\n    return false;\n  }\n\n  const opntInControl = isInControl(oppActionStateId);\n  const opntDidLoseStock = prevOpponentFrame && didLoseStock(opponentFrame, prevOpponentFrame);\n\n  // Update percent if opponent didn't lose stock\n  if (!opntDidLoseStock) {\n    state.conversion.currentPercent = opponentFrame.percent ?? 0;\n  }\n\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    // If opponent got grabbed or damaged, reset the reset counter\n    state.resetCounter = 0;\n  }\n\n  const shouldStartResetCounter = state.resetCounter === 0 && opntInControl;\n  const shouldContinueResetCounter = state.resetCounter > 0;\n  if (shouldStartResetCounter || shouldContinueResetCounter) {\n    // This will increment the reset timer under the following conditions:\n    // 1) if we were punishing opponent but they have now entered an actionable state\n    // 2) if counter has already started counting meaning opponent has entered actionable state\n    state.resetCounter += 1;\n  }\n\n  let shouldTerminate = false;\n\n  // Termination condition 1 - player kills opponent\n  if (opntDidLoseStock) {\n    state.conversion.didKill = true;\n    shouldTerminate = true;\n  }\n\n  // Termination condition 2 - conversion resets on time\n  if (state.resetCounter > Timers.PUNISH_RESET_FRAMES) {\n    shouldTerminate = true;\n  }\n\n  // If conversion should terminate, mark the end states and add it to list\n  if (shouldTerminate) {\n    state.conversion.endFrame = playerFrame.frame;\n    state.conversion.endPercent = prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0;\n\n    state.conversion = null;\n    state.move = null;\n  }\n\n  return shouldTerminate;\n}\n"],"names":["ConversionComputer","EventEmitter","constructor","playerPermutations","Array","conversions","state","Map","metadata","settings","lastEndFrameByOppIdx","setup","getSinglesPlayerPermutationsFromSettings","forEach","indices","playerState","conversion","move","resetCounter","lastHitAnimation","set","processFrame","frame","allFrames","get","terminated","handleConversionCompute","emit","combo","last","fetch","_populateConversionTypes","conversionsToHandle","filter","openingType","groupedConversions","groupBy","sortedConversions","orderBy","isTrade","length","playerIndex","endFrame","lastMove","moves","oppEndFrame","isCounterAttack","startFrame","frames","currentFrameNumber","playerFrame","players","post","opponentFrame","opponentIndex","prevFrameNumber","prevPlayerFrame","prevOpponentFrame","oppActionStateId","actionStateId","opntIsDamaged","isDamaged","opntIsGrabbed","isGrabbed","opntIsCommandGrabbed","isCommandGrabbed","opntDamageTaken","calcDamageTaken","actionChangedSinceHit","actionCounter","actionStateCounter","prevActionCounter","actionFrameCounterReset","lastHitBy","startPercent","percent","currentPercent","endPercent","didKill","push","moveId","lastAttackLanded","hitCount","damage","opntInControl","isInControl","opntDidLoseStock","didLoseStock","shouldStartResetCounter","shouldContinueResetCounter","shouldTerminate","Timers","PUNISH_RESET_FRAMES"],"mappings":"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"}