{"version":3,"file":"combos.esm.js","sources":["../../src/stats/combos.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\nimport { last } from \"lodash\";\n\nimport type { FrameEntryType, FramesType, GameStartType, PostFrameUpdateType } from \"../types\";\nimport type { ComboType, MoveLandedType, PlayerIndexedType } from \"./common\";\nimport {\n  calcDamageTaken,\n  didLoseStock,\n  getSinglesPlayerPermutationsFromSettings,\n  isCommandGrabbed,\n  isDamaged,\n  isDead,\n  isDown,\n  isGrabbed,\n  isTeching,\n  Timers,\n} from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\nexport enum ComboEvent {\n  COMBO_START = \"COMBO_START\",\n  COMBO_EXTEND = \"COMBO_EXTEND\",\n  COMBO_END = \"COMBO_END\",\n}\n\ninterface ComboState {\n  combo: ComboType | null;\n  move: MoveLandedType | null;\n  resetCounter: number;\n  lastHitAnimation: number | null;\n  event: ComboEvent | null;\n}\n\nexport class ComboComputer extends EventEmitter implements StatComputer<ComboType[]> {\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private state = new Map<PlayerIndexedType, ComboState>();\n  private combos = new Array<ComboType>();\n  private settings: GameStartType | null = null;\n\n  public setup(settings: GameStartType): void {\n    // Reset the state\n    this.settings = settings;\n    this.state = new Map();\n    this.combos = [];\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: ComboState = {\n        combo: null,\n        move: null,\n        resetCounter: 0,\n        lastHitAnimation: null,\n        event: null,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleComboCompute(allFrames, state, indices, frame, this.combos);\n\n        // Emit an event for the new combo\n        if (state.event !== null) {\n          this.emit(state.event, {\n            combo: last(this.combos),\n            settings: this.settings,\n          });\n          state.event = null;\n        }\n      }\n    });\n  }\n\n  public fetch(): ComboType[] {\n    return this.combos;\n  }\n}\n\nfunction handleComboCompute(\n  frames: FramesType,\n  state: ComboState,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n  combos: ComboType[],\n): void {\n  const currentFrameNumber = frame.frame;\n  const playerFrame = frame.players[indices.playerIndex]!.post;\n  const opponentFrame = frame.players[indices.opponentIndex]!.post;\n\n  const prevFrameNumber = currentFrameNumber - 1;\n  let prevPlayerFrame: PostFrameUpdateType | null = null;\n  let prevOpponentFrame: PostFrameUpdateType | null = null;\n\n  if (frames[prevFrameNumber]) {\n    prevPlayerFrame = frames[prevFrameNumber]!.players[indices.playerIndex]!.post;\n    prevOpponentFrame = frames[prevFrameNumber]!.players[indices.opponentIndex]!.post;\n  }\n\n  const oppActionStateId = opponentFrame.actionStateId!;\n  const opntIsDamaged = isDamaged(oppActionStateId);\n  const opntIsGrabbed = isGrabbed(oppActionStateId);\n  const opntIsCommandGrabbed = isCommandGrabbed(oppActionStateId);\n  const opntDamageTaken = prevOpponentFrame ? calcDamageTaken(opponentFrame, prevOpponentFrame) : 0;\n\n  // Keep track of whether actionState changes after a hit. Used to compute move count\n  // When purely using action state there was a bug where if you did two of the same\n  // move really fast (such as ganon's jab), it would count as one move. Added\n  // the actionStateCounter at this point which counts the number of frames since\n  // an animation started. Should be more robust, for old files it should always be\n  // null and null < null = false\n  const actionChangedSinceHit = playerFrame.actionStateId !== state.lastHitAnimation;\n  const actionCounter = playerFrame.actionStateCounter!;\n  const prevActionCounter = prevPlayerFrame ? prevPlayerFrame.actionStateCounter! : 0;\n  const actionFrameCounterReset = actionCounter < prevActionCounter;\n  if (actionChangedSinceHit || actionFrameCounterReset) {\n    state.lastHitAnimation = null;\n  }\n\n  // If opponent took damage and was put in some kind of stun this frame, either\n  // start a combo or count the moves for the existing combo\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    let comboStarted = false;\n    if (!state.combo) {\n      state.combo = {\n        playerIndex: indices.opponentIndex,\n        startFrame: currentFrameNumber,\n        endFrame: null,\n        startPercent: prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0,\n        currentPercent: opponentFrame.percent ?? 0,\n        endPercent: null,\n        moves: [],\n        didKill: false,\n        lastHitBy: indices.playerIndex,\n      };\n\n      combos.push(state.combo);\n\n      // Track whether this is a new combo or not\n      comboStarted = true;\n    }\n\n    if (opntDamageTaken) {\n      // If animation of last hit has been cleared that means this is a new move. This\n      // prevents counting multiple hits from the same move such as fox's drill\n      if (state.lastHitAnimation === null) {\n        state.move = {\n          playerIndex: indices.playerIndex,\n          frame: currentFrameNumber,\n          moveId: playerFrame.lastAttackLanded!,\n          hitCount: 0,\n          damage: 0,\n        };\n\n        state.combo.moves.push(state.move);\n\n        // Make sure we don't overwrite the START event\n        if (!comboStarted) {\n          state.event = ComboEvent.COMBO_EXTEND;\n        }\n      }\n\n      if (state.move) {\n        state.move.hitCount += 1;\n        state.move.damage += opntDamageTaken;\n      }\n\n      // Store previous frame animation to consider the case of a trade, the previous\n      // frame should always be the move that actually connected... I hope\n      state.lastHitAnimation = prevPlayerFrame ? prevPlayerFrame.actionStateId : null;\n    }\n\n    if (comboStarted) {\n      state.event = ComboEvent.COMBO_START;\n    }\n  }\n\n  if (!state.combo) {\n    // The rest of the function handles combo termination logic, so if we don't\n    // have a combo started, there is no need to continue\n    return;\n  }\n\n  const opntIsTeching = isTeching(oppActionStateId);\n  const opntIsDowned = isDown(oppActionStateId);\n  const opntDidLoseStock = prevOpponentFrame && didLoseStock(opponentFrame, prevOpponentFrame);\n  const opntIsDying = isDead(oppActionStateId);\n\n  // Update percent if opponent didn't lose stock\n  if (!opntDidLoseStock) {\n    state.combo.currentPercent = opponentFrame.percent ?? 0;\n  }\n\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed || opntIsTeching || opntIsDowned || opntIsDying) {\n    // If opponent got grabbed or damaged, reset the reset counter\n    state.resetCounter = 0;\n  } else {\n    state.resetCounter += 1;\n  }\n\n  let shouldTerminate = false;\n\n  // Termination condition 1 - player kills opponent\n  if (opntDidLoseStock) {\n    state.combo.didKill = true;\n    shouldTerminate = true;\n  }\n\n  // Termination condition 2 - combo resets on time\n  if (state.resetCounter > Timers.COMBO_STRING_RESET_FRAMES) {\n    shouldTerminate = true;\n  }\n\n  // If combo should terminate, mark the end states and add it to list\n  if (shouldTerminate) {\n    state.combo.endFrame = playerFrame.frame;\n    state.combo.endPercent = prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0;\n    state.event = ComboEvent.COMBO_END;\n\n    state.combo = null;\n    state.move = null;\n  }\n}\n"],"names":["ComboEvent","ComboComputer","EventEmitter","playerPermutations","Array","state","Map","combos","settings","setup","getSinglesPlayerPermutationsFromSettings","forEach","indices","playerState","combo","move","resetCounter","lastHitAnimation","event","set","processFrame","frame","allFrames","get","handleComboCompute","emit","last","fetch","frames","currentFrameNumber","playerFrame","players","playerIndex","post","opponentFrame","opponentIndex","prevFrameNumber","prevPlayerFrame","prevOpponentFrame","oppActionStateId","actionStateId","opntIsDamaged","isDamaged","opntIsGrabbed","isGrabbed","opntIsCommandGrabbed","isCommandGrabbed","opntDamageTaken","calcDamageTaken","actionChangedSinceHit","actionCounter","actionStateCounter","prevActionCounter","actionFrameCounterReset","comboStarted","startFrame","endFrame","startPercent","percent","currentPercent","endPercent","moves","didKill","lastHitBy","push","moveId","lastAttackLanded","hitCount","damage","COMBO_EXTEND","COMBO_START","opntIsTeching","isTeching","opntIsDowned","isDown","opntDidLoseStock","didLoseStock","opntIsDying","isDead","shouldTerminate","Timers","COMBO_STRING_RESET_FRAMES","COMBO_END"],"mappings":";;;;IAmBYA;;AAAZ,WAAYA;AACVA,EAAAA,yBAAA,gBAAA;AACAA,EAAAA,0BAAA,iBAAA;AACAA,EAAAA,uBAAA,cAAA;AACD,CAJD,EAAYA,UAAU,KAAVA,UAAU,KAAA,CAAtB;;MAcaC,sBAAsBC;;;SACzBC,qBAAqB,IAAIC,KAAJ;SACrBC,QAAQ,IAAIC,GAAJ;SACRC,SAAS,IAAIH,KAAJ;SACTI,WAAiC;;;AAElCC,EAAAA,KAAK,CAACD,QAAD;AACV;AACA,SAAKA,QAAL,GAAgBA,QAAhB;AACA,SAAKH,KAAL,GAAa,IAAIC,GAAJ,EAAb;AACA,SAAKC,MAAL,GAAc,EAAd;AACA,SAAKJ,kBAAL,GAA0BO,wCAAwC,CAACF,QAAD,CAAlE;AAEA,SAAKL,kBAAL,CAAwBQ,OAAxB,CAAiCC,OAAD;AAC9B,YAAMC,WAAW,GAAe;AAC9BC,QAAAA,KAAK,EAAE,IADuB;AAE9BC,QAAAA,IAAI,EAAE,IAFwB;AAG9BC,QAAAA,YAAY,EAAE,CAHgB;AAI9BC,QAAAA,gBAAgB,EAAE,IAJY;AAK9BC,QAAAA,KAAK,EAAE;AALuB,OAAhC;AAOA,WAAKb,KAAL,CAAWc,GAAX,CAAeP,OAAf,EAAwBC,WAAxB;AACD,KATD;AAUD;;AAEMO,EAAAA,YAAY,CAACC,KAAD,EAAwBC,SAAxB;AACjB,SAAKnB,kBAAL,CAAwBQ,OAAxB,CAAiCC,OAAD;AAC9B,YAAMP,KAAK,GAAG,KAAKA,KAAL,CAAWkB,GAAX,CAAeX,OAAf,CAAd;;AACA,UAAIP,KAAJ,EAAW;AACTmB,QAAAA,kBAAkB,CAACF,SAAD,EAAYjB,KAAZ,EAAmBO,OAAnB,EAA4BS,KAA5B,EAAmC,KAAKd,MAAxC,CAAlB,CADS;;AAIT,YAAIF,KAAK,CAACa,KAAN,KAAgB,IAApB,EAA0B;AACxB,eAAKO,IAAL,CAAUpB,KAAK,CAACa,KAAhB,EAAuB;AACrBJ,YAAAA,KAAK,EAAEY,IAAI,CAAC,KAAKnB,MAAN,CADU;AAErBC,YAAAA,QAAQ,EAAE,KAAKA;AAFM,WAAvB;AAIAH,UAAAA,KAAK,CAACa,KAAN,GAAc,IAAd;AACD;AACF;AACF,KAdD;AAeD;;AAEMS,EAAAA,KAAK;AACV,WAAO,KAAKpB,MAAZ;AACD;;;;AAGH,SAASiB,kBAAT,CACEI,MADF,EAEEvB,KAFF,EAGEO,OAHF,EAIES,KAJF,EAKEd,MALF;AAOE,QAAMsB,kBAAkB,GAAGR,KAAK,CAACA,KAAjC;AACA,QAAMS,WAAW,GAAGT,KAAK,CAACU,OAAN,CAAcnB,OAAO,CAACoB,WAAtB,EAAoCC,IAAxD;AACA,QAAMC,aAAa,GAAGb,KAAK,CAACU,OAAN,CAAcnB,OAAO,CAACuB,aAAtB,EAAsCF,IAA5D;AAEA,QAAMG,eAAe,GAAGP,kBAAkB,GAAG,CAA7C;AACA,MAAIQ,eAAe,GAA+B,IAAlD;AACA,MAAIC,iBAAiB,GAA+B,IAApD;;AAEA,MAAIV,MAAM,CAACQ,eAAD,CAAV,EAA6B;AAC3BC,IAAAA,eAAe,GAAGT,MAAM,CAACQ,eAAD,CAAN,CAAyBL,OAAzB,CAAiCnB,OAAO,CAACoB,WAAzC,EAAuDC,IAAzE;AACAK,IAAAA,iBAAiB,GAAGV,MAAM,CAACQ,eAAD,CAAN,CAAyBL,OAAzB,CAAiCnB,OAAO,CAACuB,aAAzC,EAAyDF,IAA7E;AACD;;AAED,QAAMM,gBAAgB,GAAGL,aAAa,CAACM,aAAvC;AACA,QAAMC,aAAa,GAAGC,SAAS,CAACH,gBAAD,CAA/B;AACA,QAAMI,aAAa,GAAGC,SAAS,CAACL,gBAAD,CAA/B;AACA,QAAMM,oBAAoB,GAAGC,gBAAgB,CAACP,gBAAD,CAA7C;AACA,QAAMQ,eAAe,GAAGT,iBAAiB,GAAGU,eAAe,CAACd,aAAD,EAAgBI,iBAAhB,CAAlB,GAAuD,CAAhG;AAGA;AACA;AACA;AACA;AACA;;AACA,QAAMW,qBAAqB,GAAGnB,WAAW,CAACU,aAAZ,KAA8BnC,KAAK,CAACY,gBAAlE;AACA,QAAMiC,aAAa,GAAGpB,WAAW,CAACqB,kBAAlC;AACA,QAAMC,iBAAiB,GAAGf,eAAe,GAAGA,eAAe,CAACc,kBAAnB,GAAyC,CAAlF;AACA,QAAME,uBAAuB,GAAGH,aAAa,GAAGE,iBAAhD;;AACA,MAAIH,qBAAqB,IAAII,uBAA7B,EAAsD;AACpDhD,IAAAA,KAAK,CAACY,gBAAN,GAAyB,IAAzB;AACD;AAGD;;;AACA,MAAIwB,aAAa,IAAIE,aAAjB,IAAkCE,oBAAtC,EAA4D;AAC1D,QAAIS,YAAY,GAAG,KAAnB;;AACA,QAAI,CAACjD,KAAK,CAACS,KAAX,EAAkB;AAAA;;AAChBT,MAAAA,KAAK,CAACS,KAAN,GAAc;AACZkB,QAAAA,WAAW,EAAEpB,OAAO,CAACuB,aADT;AAEZoB,QAAAA,UAAU,EAAE1B,kBAFA;AAGZ2B,QAAAA,QAAQ,EAAE,IAHE;AAIZC,QAAAA,YAAY,EAAEnB,iBAAiB,4BAAGA,iBAAiB,CAACoB,OAArB,oCAAgC,CAAhC,GAAoC,CAJvD;AAKZC,QAAAA,cAAc,2BAAEzB,aAAa,CAACwB,OAAhB,oCAA2B,CAL7B;AAMZE,QAAAA,UAAU,EAAE,IANA;AAOZC,QAAAA,KAAK,EAAE,EAPK;AAQZC,QAAAA,OAAO,EAAE,KARG;AASZC,QAAAA,SAAS,EAAEnD,OAAO,CAACoB;AATP,OAAd;AAYAzB,MAAAA,MAAM,CAACyD,IAAP,CAAY3D,KAAK,CAACS,KAAlB,EAbgB;;AAgBhBwC,MAAAA,YAAY,GAAG,IAAf;AACD;;AAED,QAAIP,eAAJ,EAAqB;AACnB;AACA;AACA,UAAI1C,KAAK,CAACY,gBAAN,KAA2B,IAA/B,EAAqC;AACnCZ,QAAAA,KAAK,CAACU,IAAN,GAAa;AACXiB,UAAAA,WAAW,EAAEpB,OAAO,CAACoB,WADV;AAEXX,UAAAA,KAAK,EAAEQ,kBAFI;AAGXoC,UAAAA,MAAM,EAAEnC,WAAW,CAACoC,gBAHT;AAIXC,UAAAA,QAAQ,EAAE,CAJC;AAKXC,UAAAA,MAAM,EAAE;AALG,SAAb;AAQA/D,QAAAA,KAAK,CAACS,KAAN,CAAY+C,KAAZ,CAAkBG,IAAlB,CAAuB3D,KAAK,CAACU,IAA7B,EATmC;;AAYnC,YAAI,CAACuC,YAAL,EAAmB;AACjBjD,UAAAA,KAAK,CAACa,KAAN,GAAclB,UAAU,CAACqE,YAAzB;AACD;AACF;;AAED,UAAIhE,KAAK,CAACU,IAAV,EAAgB;AACdV,QAAAA,KAAK,CAACU,IAAN,CAAWoD,QAAX,IAAuB,CAAvB;AACA9D,QAAAA,KAAK,CAACU,IAAN,CAAWqD,MAAX,IAAqBrB,eAArB;AACD,OAvBkB;AA0BnB;;;AACA1C,MAAAA,KAAK,CAACY,gBAAN,GAAyBoB,eAAe,GAAGA,eAAe,CAACG,aAAnB,GAAmC,IAA3E;AACD;;AAED,QAAIc,YAAJ,EAAkB;AAChBjD,MAAAA,KAAK,CAACa,KAAN,GAAclB,UAAU,CAACsE,WAAzB;AACD;AACF;;AAED,MAAI,CAACjE,KAAK,CAACS,KAAX,EAAkB;AAChB;AACA;AACA;AACD;;AAED,QAAMyD,aAAa,GAAGC,SAAS,CAACjC,gBAAD,CAA/B;AACA,QAAMkC,YAAY,GAAGC,MAAM,CAACnC,gBAAD,CAA3B;AACA,QAAMoC,gBAAgB,GAAGrC,iBAAiB,IAAIsC,YAAY,CAAC1C,aAAD,EAAgBI,iBAAhB,CAA1D;AACA,QAAMuC,WAAW,GAAGC,MAAM,CAACvC,gBAAD,CAA1B;;AAGA,MAAI,CAACoC,gBAAL,EAAuB;AAAA;;AACrBtE,IAAAA,KAAK,CAACS,KAAN,CAAY6C,cAAZ,6BAA6BzB,aAAa,CAACwB,OAA3C,qCAAsD,CAAtD;AACD;;AAED,MAAIjB,aAAa,IAAIE,aAAjB,IAAkCE,oBAAlC,IAA0D0B,aAA1D,IAA2EE,YAA3E,IAA2FI,WAA/F,EAA4G;AAC1G;AACAxE,IAAAA,KAAK,CAACW,YAAN,GAAqB,CAArB;AACD,GAHD,MAGO;AACLX,IAAAA,KAAK,CAACW,YAAN,IAAsB,CAAtB;AACD;;AAED,MAAI+D,eAAe,GAAG,KAAtB;;AAGA,MAAIJ,gBAAJ,EAAsB;AACpBtE,IAAAA,KAAK,CAACS,KAAN,CAAYgD,OAAZ,GAAsB,IAAtB;AACAiB,IAAAA,eAAe,GAAG,IAAlB;AACD;;;AAGD,MAAI1E,KAAK,CAACW,YAAN,GAAqBgE,MAAM,CAACC,yBAAhC,EAA2D;AACzDF,IAAAA,eAAe,GAAG,IAAlB;AACD;;;AAGD,MAAIA,eAAJ,EAAqB;AAAA;;AACnB1E,IAAAA,KAAK,CAACS,KAAN,CAAY0C,QAAZ,GAAuB1B,WAAW,CAACT,KAAnC;AACAhB,IAAAA,KAAK,CAACS,KAAN,CAAY8C,UAAZ,GAAyBtB,iBAAiB,6BAAGA,iBAAiB,CAACoB,OAArB,qCAAgC,CAAhC,GAAoC,CAA9E;AACArD,IAAAA,KAAK,CAACa,KAAN,GAAclB,UAAU,CAACkF,SAAzB;AAEA7E,IAAAA,KAAK,CAACS,KAAN,GAAc,IAAd;AACAT,IAAAA,KAAK,CAACU,IAAN,GAAa,IAAb;AACD;AACF;;;;"}