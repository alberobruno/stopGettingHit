/**
 * Copyright IBM Corp. 2016, 2023
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../_virtual/_rollupPluginBabelHelpers.js');
var React = require('react');
var PropTypes = require('prop-types');
var isEqual = require('lodash.isequal');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);
var isEqual__default = /*#__PURE__*/_interopDefaultLegacy(isEqual);

function callOnChangeHandler(_ref) {
  let {
    isControlled,
    isMounted,
    onChangeHandlerControlled,
    onChangeHandlerUncontrolled,
    selectedItems
  } = _ref;
  if (isControlled) {
    if (isMounted && onChangeHandlerControlled) {
      onChangeHandlerControlled({
        selectedItems
      });
    }
  } else {
    onChangeHandlerUncontrolled(selectedItems);
  }
}
function useSelection(_ref2) {
  let {
    disabled,
    onChange,
    initialSelectedItems = [],
    selectedItems: controlledItems
  } = _ref2;
  const isMounted = React.useRef(false);
  const savedOnChange = React.useRef(onChange);
  const [uncontrolledItems, setUncontrolledItems] = React.useState(initialSelectedItems);
  const isControlled = !!controlledItems;
  const selectedItems = isControlled ? controlledItems : uncontrolledItems;
  const onItemChange = React.useCallback(item => {
    if (disabled) {
      return;
    }
    let selectedIndex;
    selectedItems.forEach((selectedItem, index) => {
      if (isEqual__default["default"](selectedItem, item)) {
        selectedIndex = index;
      }
    });
    let newSelectedItems;
    if (selectedIndex === undefined) {
      newSelectedItems = selectedItems.concat(item);
      callOnChangeHandler({
        isControlled,
        isMounted: isMounted.current,
        onChangeHandlerControlled: savedOnChange.current,
        onChangeHandlerUncontrolled: setUncontrolledItems,
        selectedItems: newSelectedItems
      });
      return;
    }
    newSelectedItems = removeAtIndex(selectedItems, selectedIndex);
    callOnChangeHandler({
      isControlled,
      isMounted: isMounted.current,
      onChangeHandlerControlled: savedOnChange.current,
      onChangeHandlerUncontrolled: setUncontrolledItems,
      selectedItems: newSelectedItems
    });
  }, [disabled, isControlled, selectedItems]);
  const clearSelection = React.useCallback(() => {
    if (disabled) {
      return;
    }
    callOnChangeHandler({
      isControlled,
      isMounted: isMounted.current,
      onChangeHandlerControlled: savedOnChange.current,
      onChangeHandlerUncontrolled: setUncontrolledItems,
      selectedItems: []
    });
  }, [disabled, isControlled]);
  React.useEffect(() => {
    savedOnChange.current = onChange;
  }, [onChange]);
  React.useEffect(() => {
    if (isMounted.current && savedOnChange.current && !isControlled) {
      savedOnChange.current({
        selectedItems
      });
    }
  }, [isControlled, selectedItems]);
  React.useEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return {
    selectedItems,
    onItemChange,
    clearSelection
  };
}
class Selection extends React__default["default"].Component {
  constructor(props) {
    super(props);
    _rollupPluginBabelHelpers.defineProperty(this, "internalSetState", (stateToSet, callback) => this.setState(stateToSet, () => {
      if (callback) {
        callback();
      }
      if (this.props.onChange) {
        this.props.onChange(this.state);
      }
    }));
    _rollupPluginBabelHelpers.defineProperty(this, "handleClearSelection", () => {
      if (this.props.disabled) {
        return;
      }
      this.internalSetState({
        selectedItems: []
      });
    });
    _rollupPluginBabelHelpers.defineProperty(this, "handleSelectItem", item => {
      this.internalSetState(state => ({
        selectedItems: state.selectedItems.concat(item)
      }));
    });
    _rollupPluginBabelHelpers.defineProperty(this, "handleRemoveItem", index => {
      this.internalSetState(state => ({
        selectedItems: removeAtIndex(state.selectedItems, index)
      }));
    });
    _rollupPluginBabelHelpers.defineProperty(this, "handleOnItemChange", item => {
      if (this.props.disabled) {
        return;
      }
      const {
        selectedItems
      } = this.state;
      let selectedIndex;
      selectedItems.forEach((selectedItem, index) => {
        if (isEqual__default["default"](selectedItem, item)) {
          selectedIndex = index;
        }
      });
      if (selectedIndex === undefined) {
        this.handleSelectItem(item);
        return;
      }
      this.handleRemoveItem(selectedIndex);
    });
    this.state = {
      selectedItems: props.initialSelectedItems
    };
  }
  render() {
    const {
      children,
      render
    } = this.props;
    const {
      selectedItems
    } = this.state;
    const renderProps = {
      selectedItems,
      onItemChange: this.handleOnItemChange,
      clearSelection: this.handleClearSelection
    };
    if (render !== undefined) {
      return render(renderProps);
    }
    if (children !== undefined) {
      return children(renderProps);
    }
    return null;
  }
}

// Generic utility for safely removing an element at a given index from an
// array.
_rollupPluginBabelHelpers.defineProperty(Selection, "propTypes", {
  children: PropTypes__default["default"].func,
  disabled: PropTypes__default["default"].bool,
  initialSelectedItems: PropTypes__default["default"].array.isRequired,
  onChange: PropTypes__default["default"].func,
  render: PropTypes__default["default"].func
});
const removeAtIndex = (array, index) => {
  const result = array.slice();
  result.splice(index, 1);
  return result;
};

exports["default"] = Selection;
exports.useSelection = useSelection;
