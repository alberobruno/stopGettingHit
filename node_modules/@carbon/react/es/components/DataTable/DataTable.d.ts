/**
 * Copyright IBM Corp. 2016, 2023
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
import PropTypes from 'prop-types';
import React from 'react';
import type { DataTableSortState } from './state/sortStates';
import Table from './Table';
import TableActionList from './TableActionList';
import TableBatchAction from './TableBatchAction';
import TableBatchActions from './TableBatchActions';
import TableBody from './TableBody';
import TableCell from './TableCell';
import TableContainer from './TableContainer';
import TableExpandHeader from './TableExpandHeader';
import TableExpandRow from './TableExpandRow';
import TableExpandedRow from './TableExpandedRow';
import TableHead from './TableHead';
import TableHeader from './TableHeader';
import TableRow from './TableRow';
import TableSelectAll from './TableSelectAll';
import TableSelectRow from './TableSelectRow';
import TableToolbar from './TableToolbar';
import TableToolbarAction from './TableToolbarAction';
import TableToolbarContent from './TableToolbarContent';
import TableToolbarSearch from './TableToolbarSearch';
import TableToolbarMenu from './TableToolbarMenu';
export type DataTableSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl';
export interface DataTableCell<T> {
    id: string;
    value: T;
    isEditable: boolean;
    isEditing: boolean;
    isValid: boolean;
    errors: null | Array<Error>;
    info: {
        header: string;
    };
}
type DataTableCells<T extends any[]> = {
    [K in keyof T]: DataTableCell<T[K]>;
};
export interface DataTableRow<ColTypes extends any[]> {
    id: string;
    cells: DataTableCells<ColTypes>;
    disabled?: boolean;
    isExpanded?: boolean;
    isSelected?: boolean;
}
export interface DataTableHeader {
    key: string;
    header: React.ReactNode;
}
export interface DataTableRenderProps<RowType, ColTypes extends any[]> {
    headers: Array<DataTableHeader>;
    rows: Array<DataTableRow<ColTypes> & RowType>;
    selectedRows: Array<DataTableRow<ColTypes> & RowType>;
    getHeaderProps: (getHeaderPropsArgs: {
        header: DataTableHeader;
        isSortable?: boolean;
        onClick?: (e: React.MouseEvent, sortState: {
            sortHeaderKey: string;
            sortDirection: DataTableSortState;
        }) => void;
        [key: string]: unknown;
    }) => {
        isSortable: boolean | undefined;
        isSortHeader: boolean;
        key: string;
        onClick: (e: MouseEvent) => void;
        sortDirection: DataTableSortState;
        [key: string]: unknown;
    };
    getExpandHeaderProps: (getExpandHeaderPropsArgs?: {
        onClick?: (e: MouseEvent, expandState: {
            isExpanded?: boolean;
        }) => void;
        onExpand?: (e: MouseEvent) => void;
        [key: string]: unknown;
    }) => {
        ariaLabel: string;
        ['aria-label']: string;
        isExpanded: boolean;
        onExpand: (e: MouseEvent) => void;
        [key: string]: unknown;
    };
    getRowProps: (getRowPropsArgs: {
        onClick?: (e: MouseEvent) => void;
        row: DataTableRow<ColTypes>;
        [key: string]: unknown;
    }) => {
        ariaLabel: string;
        ['aria-label']: string;
        disabled: boolean | undefined;
        isExpanded?: boolean;
        isSelected?: boolean;
        key: string;
        onExpand: (e: MouseEvent) => void;
        [key: string]: unknown;
    };
    getExpandedRowProps: (getExpandedRowPropsArgs: {
        row: DataTableRow<ColTypes>;
        [key: string]: unknown;
    }) => {
        ['id']: string;
        [key: string]: unknown;
    };
    getSelectionProps: (getSelectionPropsArgs: {
        onClick?: (e: MouseEvent) => void;
        row: DataTableRow<ColTypes>;
        [key: string]: unknown;
    }) => {
        ariaLabel: string;
        checked: boolean | undefined;
        disabled?: boolean | undefined;
        id: string;
        indeterminate?: boolean;
        name: string;
        onSelect: (e: MouseEvent) => void;
        radio?: boolean | null;
        [key: string]: unknown;
    };
    getToolbarProps: (getToolbarPropsArgs?: {
        [key: string]: unknown;
    }) => {
        size: 'sm' | undefined;
        [key: string]: unknown;
    };
    getBatchActionProps: (getBatchActionPropsArgs?: {
        [key: string]: unknown;
    }) => {
        onCancel: () => void;
        onSelectAll?: () => void | undefined;
        shouldShowBatchActions: boolean;
        totalCount: number;
        totalSelected: number;
        [key: string]: unknown;
    };
    getTableProps: () => {
        experimentalAutoAlign?: boolean;
        isSortable?: boolean;
        overflowMenuOnHover: boolean;
        size: DataTableSize;
        stickyHeader?: boolean;
        useStaticWidth?: boolean;
        useZebraStyles?: boolean;
    };
    getTableContainerProps: () => {
        stickyHeader?: boolean;
        useStaticWidth?: boolean;
    };
    onInputChange: (e: React.ChangeEvent<HTMLInputElement>, defaultValue?: string) => void;
    sortBy: (headerKey: string) => void;
    selectAll: () => void;
    selectRow: (rowId: string) => void;
    expandRow: (rowId: string) => void;
    expandAll: () => void;
    radio: boolean | undefined;
}
export interface DataTableProps<RowType, ColTypes extends any[]> {
    children?: (renderProps: DataTableRenderProps<RowType, ColTypes>) => React.ReactElement;
    experimentalAutoAlign?: boolean;
    filterRows?: (filterRowsArgs: {
        cellsById: Record<string, DataTableCell<ColTypes>>;
        getCellId: (rowId: string, header: string) => string;
        headers: Array<DataTableHeader>;
        inputValue: string;
        rowIds: Array<string>;
    }) => Array<string>;
    headers: Array<DataTableHeader>;
    isSortable?: boolean;
    locale?: string;
    overflowMenuOnHover?: boolean;
    radio?: boolean;
    render?: (renderProps: DataTableRenderProps<RowType, ColTypes>) => React.ReactElement;
    rows: Array<Omit<DataTableRow<ColTypes>, 'cells'>>;
    size?: DataTableSize;
    sortRow?: (cellA: DataTableCell<any>, cellB: DataTableCell<any>, sortRowOptions: {
        sortDirection: DataTableSortState;
        sortStates: Record<DataTableSortState, DataTableSortState>;
        locale: string;
    }) => number;
    stickyHeader?: boolean;
    translateWithId?: (id: string) => string;
    useStaticWidth?: boolean;
    useZebraStyles?: boolean;
}
interface DataTableState<ColTypes extends any[]> {
    cellsById: Record<string, DataTableCell<ColTypes>>;
    filterInputValue: string | null;
    initialRowOrder: Array<string>;
    isExpandedAll: boolean;
    rowIds: Array<string>;
    rowsById: Record<string, DataTableRow<ColTypes>>;
    shouldShowBatchActions: boolean;
    sortDirection: DataTableSortState;
    sortHeaderKey: string | null;
}
/**
 * Data Tables are used to represent a collection of resources, displaying a
 * subset of their fields in columns, or headers. We prioritize direct updates
 * to the state of what we're rendering, so internally we end up normalizing the
 * given data and then denormalizing it when rendering.
 *
 * As a result, each part of the DataTable is accessible through look-up by id,
 * and updating the state of the single entity will cascade updates to the
 * consumer.
 */
declare class DataTable<RowType, ColTypes extends any[]> extends React.Component<DataTableProps<RowType, ColTypes>, DataTableState<ColTypes>> {
    instanceId: number;
    static propTypes: {
        /**
         * Experimental property. Allows table to align cell contents to the top if there is text wrapping in the content. Might have performance issues, intended for smaller tables
         */
        experimentalAutoAlign: PropTypes.Requireable<boolean>;
        /**
         * Optional hook to manually control filtering of the rows from the
         * TableToolbarSearch component
         */
        filterRows: PropTypes.Requireable<(...args: any[]) => any>;
        /**
         * The `headers` prop represents the order in which the headers should
         * appear in the table. We expect an array of objects to be passed in, where
         * `key` is the name of the key in a row object, and `header` is the name of
         * the header.
         */
        headers: PropTypes.Validator<(PropTypes.InferProps<{
            key: PropTypes.Validator<string>;
            header: PropTypes.Validator<NonNullable<PropTypes.ReactNodeLike>>;
        }> | null | undefined)[]>;
        /**
         * Specify whether the table should be able to be sorted by its headers
         */
        isSortable: PropTypes.Requireable<boolean>;
        /**
         * Provide a string for the current locale
         */
        locale: PropTypes.Requireable<string>;
        /**
         * Specify whether the overflow menu (if it exists) should be shown always, or only on hover
         */
        overflowMenuOnHover: PropTypes.Requireable<boolean>;
        /**
         * Specify whether the control should be a radio button or inline checkbox
         */
        radio: PropTypes.Requireable<boolean>;
        /**
         * The `rows` prop is where you provide us with a list of all the rows that
         * you want to render in the table. The only hard requirement is that this
         * is an array of objects, and that each object has a unique `id` field
         * available on it.
         */
        rows: PropTypes.Validator<(PropTypes.InferProps<{
            id: PropTypes.Validator<string>;
            disabled: PropTypes.Requireable<boolean>;
            isSelected: PropTypes.Requireable<boolean>;
            isExpanded: PropTypes.Requireable<boolean>;
        }> | null | undefined)[]>;
        /**
         *  Change the row height of table. Currently supports `xs`, `sm`, `md`, `lg`, and `xl`.
         */
        size: PropTypes.Requireable<string>;
        /**
         * Optional hook to manually control sorting of the rows.
         */
        sortRow: PropTypes.Requireable<(...args: any[]) => any>;
        /**
         * Specify whether the header should be sticky.
         * Still experimental: may not work with every combination of table props
         */
        stickyHeader: PropTypes.Requireable<boolean>;
        /**
         * Optional method that takes in a message id and returns an
         * internationalized string. See `DataTable.translationKeys` for all
         * available message ids.
         */
        translateWithId: PropTypes.Requireable<(...args: any[]) => any>;
        /**
         * `false` If true, will use a width of 'auto' instead of 100%
         */
        useStaticWidth: PropTypes.Requireable<boolean>;
        /**
         * `true` to add useZebraStyles striping.
         */
        useZebraStyles: PropTypes.Requireable<boolean>;
    };
    static translationKeys: string[];
    static Table: typeof Table;
    static TableActionList: typeof TableActionList;
    static TableBatchAction: typeof TableBatchAction;
    static TableBatchActions: typeof TableBatchActions;
    static TableBody: typeof TableBody;
    static TableCell: typeof TableCell;
    static TableContainer: typeof TableContainer;
    static TableExpandHeader: typeof TableExpandHeader;
    static TableExpandRow: typeof TableExpandRow;
    static TableExpandedRow: typeof TableExpandedRow;
    static TableHead: typeof TableHead;
    static TableHeader: typeof TableHeader;
    static TableRow: typeof TableRow;
    static TableSelectAll: typeof TableSelectAll;
    static TableSelectRow: typeof TableSelectRow;
    static TableToolbar: typeof TableToolbar;
    static TableToolbarAction: typeof TableToolbarAction;
    static TableToolbarContent: typeof TableToolbarContent;
    static TableToolbarSearch: typeof TableToolbarSearch;
    static TableToolbarMenu: typeof TableToolbarMenu;
    constructor(props: any);
    shouldComponentUpdate(nextProps: any): boolean;
    /**
     * Get the props associated with the given header. Mostly used for adding in
     * sorting behavior.
     *
     * @param {object} config
     * @param {string} config.header the header we want the props for
     * @param {Function} config.onClick a custom click handler for the header
     * @param {boolean} config.isSortable
     * @returns {object}
     */
    getHeaderProps: ({ header, onClick, isSortable, ...rest }: {
        [key: string]: unknown;
        header: DataTableHeader;
        onClick?: ((e: React.MouseEvent, sortState: {
            sortHeaderKey: string;
            sortDirection: DataTableSortState;
        }) => void) | undefined;
        isSortable?: boolean | undefined;
    }) => {
        key: string;
        sortDirection: DataTableSortState;
        isSortable: boolean | undefined;
        isSortHeader: boolean;
        onClick: (event: any) => void;
    };
    /**
     * Get the props associated with the given expand header.
     *
     * @param {object} config
     * @param {Function} config.onClick a custom click handler for the expand header
     * @param {Function} config.onExpand a custom click handler called when header is expanded
     * @returns {object}
     */
    getExpandHeaderProps: ({ onClick, onExpand, ...rest }?: {
        [key: string]: unknown;
        onClick?: ((e: MouseEvent, expandState: {
            isExpanded: boolean;
        }) => void) | undefined;
        onExpand?: ((e: MouseEvent) => void) | undefined;
    }) => {
        ariaLabel: string;
        'aria-label': string;
        'aria-controls': string;
        isExpanded: boolean;
        onExpand: any;
    };
    /**
     * Decorate consumer's `onClick` event handler with sort parameters
     *
     * @param {Function} onClick
     * @param {object} sortParams
     * @returns {Function}
     */
    handleOnHeaderClick: (onClick: any, sortParams: any) => (e: any) => any;
    /**
     * Decorate consumer's `onClick` event handler with sort parameters
     *
     * @param {Function} onClick
     * @param {object} expandParams
     * @returns {Function}
     */
    handleOnExpandHeaderClick: (onClick: any, expandParams: any) => (e: any) => any;
    /**
     * Get the props associated with the given row. Mostly used for expansion.
     *
     * @param {object} config
     * @param {object} config.row the row we want the props for
     * @param {Function} config.onClick a custom click handler for the header
     * @returns {object}
     */
    getRowProps: ({ row, onClick, ...rest }: {
        [key: string]: unknown;
        onClick?: ((e: MouseEvent) => void) | undefined;
        row: DataTableRow<ColTypes>;
    }) => {
        key: string;
        onExpand: any;
        isExpanded: boolean | undefined;
        ariaLabel: string;
        'aria-label': string;
        'aria-controls': string;
        isSelected: boolean | undefined;
        disabled: boolean | undefined;
    };
    /**
     * Get the props associated with an expanded row
     *
     * @param {object} config
     * @param {object} config.row the parent row we want the props for
     * @returns {object}
     */
    getExpandedRowProps: ({ row, ...rest }: {
        [key: string]: unknown;
        row: DataTableRow<ColTypes>;
    }) => {
        id: string;
    };
    /**
     * Gets the props associated with selection for a header or a row, where
     * applicable. Most often used to indicate selection status of the table or
     * for a specific row.
     *
     * @param {object} [row] an optional row that we want to access the props for
     * @param {Function} row.onClick
     * @param {object} row.row
     * @returns {object}
     */
    getSelectionProps: ({ onClick, row, ...rest }?: {
        [key: string]: unknown;
        onClick?: ((e: MouseEvent) => void) | undefined;
        row: DataTableRow<ColTypes>;
    }) => {
        checked: boolean | undefined;
        onSelect: any;
        id: string;
        name: string;
        ariaLabel: string;
        disabled: boolean | undefined;
        radio: true | null;
    } | {
        ariaLabel: string;
        checked: boolean;
        id: string;
        indeterminate: boolean;
        name: string;
        onSelect: any;
    };
    getToolbarProps: (props?: {}) => {
        [key: string]: unknown;
        size: 'sm' | undefined;
    };
    getBatchActionProps: (props?: {}) => {
        shouldShowBatchActions: boolean;
        totalSelected: number;
        onCancel: () => void;
        onSelectAll: undefined;
        totalCount: number;
    };
    /**
     * Helper utility to get the Table Props.
     */
    getTableProps: () => {
        useZebraStyles: boolean | undefined;
        size: DataTableSize;
        isSortable: boolean | undefined;
        useStaticWidth: boolean | undefined;
        stickyHeader: boolean | undefined;
        overflowMenuOnHover: boolean;
        experimentalAutoAlign: boolean | undefined;
    };
    /**
     * Helper utility to get the TableContainer Props.
     */
    getTableContainerProps: () => {
        stickyHeader: boolean | undefined;
        useStaticWidth: boolean | undefined;
    };
    /**
     * Helper utility to get all the currently selected rows
     * @returns {Array<string>} the array of rowIds that are currently selected
     */
    getSelectedRows: () => string[];
    /**
     * Helper utility to get all of the available rows after applying the filter
     * @returns {Array<string>} the array of rowIds that are currently included through the filter
     *  */
    getFilteredRowIds: () => string[];
    /**
     * Helper for getting the table prefix for elements that require an
     * `id` attribute that is unique.
     *
     * @returns {string}
     */
    getTablePrefix: () => string;
    /**
     * Helper for toggling all selected items in a state. Does not call
     * setState, so use it when setting state.
     * @param {object} initialState
     * @returns {object} object to put into this.setState (use spread operator)
     */
    setAllSelectedState: (initialState: any, isSelected: any, filteredRowIds: any) => {
        rowsById: any;
    };
    /**
     * Handler for the `onCancel` event to hide the batch action bar and
     * deselect all selected rows
     */
    handleOnCancel: () => void;
    /**
     * Handler for toggling the selection state of all rows in the database
     */
    handleSelectAll: () => void;
    /**
     * Handler for toggling the selection state of a given row.
     *
     * @param {string} rowId
     * @returns {Function}
     */
    handleOnSelectRow: (rowId: any) => () => void;
    /**
     * Handler for toggling the expansion state of a given row.
     *
     * @param {string} rowId
     * @returns {Function}
     */
    handleOnExpandRow: (rowId: any) => () => void;
    /**
     * Handler for changing the expansion state of all rows.
     */
    handleOnExpandAll: () => void;
    /**
     * Handler for transitioning to the next sort state of the table
     *
     * @param {string} headerKey the field for the header that we are sorting by
     * @returns {Function}
     */
    handleSortBy: (headerKey: any) => () => void;
    /**
     * Event handler for transitioning input value state changes for the table
     * filter component.
     *
     * @param {Event} event
     */
    handleOnInputValueChange: (event: any, defaultValue: any) => void;
    render(): React.ReactElement<any, string | React.JSXElementConstructor<any>> | null;
}
export default DataTable;
