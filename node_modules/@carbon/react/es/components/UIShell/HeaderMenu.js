/**
 * Copyright IBM Corp. 2016, 2023
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

import { defineProperty as _defineProperty, extends as _extends } from '../../_virtual/_rollupPluginBabelHelpers.js';
import { ChevronDown } from '@carbon/icons-react';
import cx from 'classnames';
import React__default from 'react';
import PropTypes from 'prop-types';
import { AriaLabelPropType } from '../../prop-types/AriaPropTypes.js';
import { PrefixContext } from '../../internal/usePrefix.js';
import deprecate from '../../prop-types/deprecate.js';
import { composeEventHandlers } from '../../tools/events.js';
import { matches } from '../../internal/keyboard/match.js';
import { Enter, Space, Escape } from '../../internal/keyboard/keys.js';

/**
 * `HeaderMenu` is used to render submenu's in the `Header`. Most often children
 * will be a `HeaderMenuItem`. It handles certain keyboard events to help
 * with managing focus. It also passes along refs to each child so that it can
 * help manage focus state of its children.
 */
class HeaderMenu extends React__default.Component {
  constructor(props) {
    super(props);
    _defineProperty(this, "_subMenus", /*#__PURE__*/React__default.createRef());
    /**
     * Toggle the expanded state of the menu on click.
     */
    _defineProperty(this, "handleOnClick", e => {
      const {
        current: subMenusNode
      } = this._subMenus;
      if (!subMenusNode || !subMenusNode.contains(e.target)) {
        e.preventDefault();
      }
      this.setState(prevState => ({
        expanded: !prevState.expanded
      }));
    });
    /**
     * Keyboard event handler for the entire menu.
     */
    _defineProperty(this, "handleOnKeyDown", event => {
      // Handle enter or space key for toggling the expanded state of the menu.
      if (matches(event, [Enter, Space])) {
        event.stopPropagation();
        event.preventDefault();
        this.setState(prevState => ({
          expanded: !prevState.expanded
        }));
        return;
      }
    });
    /**
     * Handle our blur event from our underlying menuitems. Will mostly be used
     * for closing our menu in response to a user clicking off or tabbing out of
     * the menu or menubar.
     */
    _defineProperty(this, "handleOnBlur", event => {
      // Close the menu on blur when the related target is not a sibling menu item
      // or a child in a submenu
      const siblingItemBlurredTo = this.items.find(element => element === event.relatedTarget);
      const childItemBlurredTo = this._subMenus.current?.contains(event.relatedTarget);
      if (!siblingItemBlurredTo && !childItemBlurredTo) {
        this.setState({
          expanded: false,
          selectedIndex: null
        });
      }
    });
    /**
     * ref handler for our menu button. If we are supplied a `focusRef` prop, we also
     * forward along the node.
     *
     * This is useful when this component is a child in a
     * menu or menubar as it will allow the parent to explicitly focus the menu
     * button node when that child should receive focus.
     */
    _defineProperty(this, "handleMenuButtonRef", node => {
      if (this.props.focusRef) {
        this.props.focusRef(node);
      }
      this.menuButtonRef = node;
    });
    /**
     * Handles individual menuitem refs. We assign them to a class instance
     * property so that we can properly manage focus of our children.
     */
    _defineProperty(this, "handleItemRef", index => node => {
      this.items[index] = node;
    });
    _defineProperty(this, "handleMenuClose", event => {
      // Handle ESC keydown for closing the expanded menu.
      if (matches(event, [Escape]) && this.state.expanded) {
        event.stopPropagation();
        event.preventDefault();
        this.setState(() => ({
          expanded: false,
          selectedIndex: null
        }));

        // Return focus to menu button when the user hits ESC.
        this.menuButtonRef.focus();
        return;
      }
    });
    /**
     * We capture the `ref` for each child inside of `this.items` to properly
     * manage focus. In addition to this focus management, all items receive a
     * `tabIndex: -1` so the user won't hit a large number of items in their tab
     * sequence when they might not want to go through all the items.
     */
    _defineProperty(this, "_renderMenuItem", (item, index) => {
      if ( /*#__PURE__*/React__default.isValidElement(item)) {
        return /*#__PURE__*/React__default.cloneElement(item, {
          ref: this.handleItemRef(index)
        });
      }
    });
    this.state = {
      // Used to manage the expansion state of the menu
      expanded: false,
      // Refers to the menuitem that is currently focused
      // Note: children should have `role="menuitem"` on node consuming ref
      selectedIndex: null
    };
    this.items = [];
  }
  render() {
    const prefix = this.context;
    const {
      isActive,
      isCurrentPage,
      'aria-label': ariaLabel,
      'aria-labelledby': ariaLabelledBy,
      className: customClassName,
      children,
      renderMenuContent: MenuContent,
      menuLinkName,
      focusRef,
      // eslint-disable-line no-unused-vars
      onBlur,
      onClick,
      onKeyDown,
      ...rest
    } = this.props;
    const hasActiveDescendant = childrenArg => React__default.Children.toArray(childrenArg).some(child => child.props.isActive || child.props.isCurrentPage || child.props.children instanceof Array && hasActiveDescendant(child.props.children));
    const accessibilityLabel = {
      'aria-label': ariaLabel,
      'aria-labelledby': ariaLabelledBy
    };
    const itemClassName = cx({
      [`${prefix}--header__submenu`]: true,
      [customClassName]: !!customClassName
    });
    let isActivePage = isActive ? isActive : isCurrentPage;
    const linkClassName = cx({
      [`${prefix}--header__menu-item`]: true,
      [`${prefix}--header__menu-title`]: true,
      // We set the current class only if `isActive` is passed in and we do
      // not have an `aria-current="page"` set for the breadcrumb item
      [`${prefix}--header__menu-item--current`]: isActivePage || hasActiveDescendant(children) && !this.state.expanded
    });

    // Notes on eslint comments and based on the examples in:
    // https://www.w3.org/TR/wai-aria-practices/examples/menubar/menubar-1/menubar-1.html#
    // - The focus is handled by the <a> menuitem, onMouseOver is for mouse
    // users
    // - aria-haspopup can definitely have the value "menu"
    // - aria-expanded is on their example node with role="menuitem"
    // - href can be set to javascript:void(0), ideally this will be a button
    return /*#__PURE__*/React__default.createElement("li", _extends({}, rest, {
      className: itemClassName,
      onKeyDown: composeEventHandlers([onKeyDown, this.handleMenuClose]),
      onClick: composeEventHandlers([onClick, this.handleOnClick]),
      onBlur: composeEventHandlers([onBlur, this.handleOnBlur])
    }), /*#__PURE__*/React__default.createElement("a", _extends({
      // eslint-disable-line jsx-a11y/role-supports-aria-props,jsx-a11y/anchor-is-valid
      "aria-haspopup": "menu" // eslint-disable-line jsx-a11y/aria-proptypes
      ,
      "aria-expanded": this.state.expanded,
      className: linkClassName,
      href: "#",
      onKeyDown: this.handleOnKeyDown,
      ref: this.handleMenuButtonRef,
      tabIndex: 0
    }, accessibilityLabel), menuLinkName, MenuContent ? /*#__PURE__*/React__default.createElement(MenuContent, null) : /*#__PURE__*/React__default.createElement(ChevronDown, {
      className: `${this.context}--header__menu-arrow`
    })), /*#__PURE__*/React__default.createElement("ul", _extends({}, accessibilityLabel, {
      ref: this._subMenus,
      className: `${prefix}--header__menu`
    }), React__default.Children.map(children, this._renderMenuItem)));
  }
}
_defineProperty(HeaderMenu, "propTypes", {
  /**
   * Required props for the accessibility label of the menu
   */
  ...AriaLabelPropType,
  /**
   * Optionally provide a custom class to apply to the underlying `<li>` node
   */
  className: PropTypes.string,
  /**
   * Provide a custom ref handler for the menu button
   */
  focusRef: PropTypes.func,
  /**
   * Applies selected styles to the item if a user sets this to true and `aria-current !== 'page'`.
   */
  isActive: PropTypes.bool,
  /**
   * Applies selected styles to the item if a user sets this to true and `aria-current !== 'page'`.
   * @deprecated Please use `isActive` instead. This will be removed in the next major release.
   */
  isCurrentPage: deprecate(PropTypes.bool, 'The `isCurrentPage` prop for `HeaderMenu` has ' + 'been deprecated. Please use `isActive` instead. This will be removed in the next major release.'),
  /**
   * Provide a label for the link text
   */
  menuLinkName: PropTypes.string.isRequired,
  /**
   * Optionally provide an onBlur handler that is called when the underlying
   * button fires it's onblur event
   */
  onBlur: PropTypes.func,
  /**
   * Optionally provide an onClick handler that is called when the underlying
   * button fires it's onclick event
   */
  onClick: PropTypes.func,
  /**
   * Optionally provide an onKeyDown handler that is called when the underlying
   * button fires it's onkeydown event
   */
  onKeyDown: PropTypes.func,
  /**
   * Optional component to render instead of string
   */
  renderMenuContent: PropTypes.func,
  /**
   * Optionally provide a tabIndex for the underlying menu button
   */
  tabIndex: PropTypes.number
});
_defineProperty(HeaderMenu, "contextType", PrefixContext);
const HeaderMenuForwardRef = /*#__PURE__*/React__default.forwardRef((props, ref) => {
  return /*#__PURE__*/React__default.createElement(HeaderMenu, _extends({}, props, {
    focusRef: ref
  }));
});
HeaderMenuForwardRef.displayName = 'HeaderMenu';
var HeaderMenuForwardRef$1 = HeaderMenuForwardRef;

export { HeaderMenu, HeaderMenuForwardRef$1 as default };
